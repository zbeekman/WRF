!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!  Differentiation of chem_driver in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: tracer grid%pm2_5_dry
!                grid%pm10 chem
!   with respect to varying inputs: scalebb tracer grid%p
!                grid%t_2 grid%pm2_5_dry grid%z
!                grid%alt grid%pm10 grid%v_2
!                scaleant grid%ph_2 moist grid%u_2
!                chem
!   RW status of diff variables: scalebb:out tracer:in-out grid%p:out
!                grid%t_2:out grid%pm2_5_dry:in-out
!                grid%z:out grid%alt:out grid%pm10:in-out
!                grid%v_2:out scaleant:out grid%ph_2:out
!                moist:out grid%u_2:out chem:in-out
SUBROUTINE chem_driver_ad(grid, config_flags &

#include "dummy_new_args.inc"

                 )
  USE module_domain , only : domain, domain_clock_get, domain_clock_set
  USE module_configure
  USE module_driver_constants
  USE module_machine
  USE module_tiles
  USE module_dm
  USE module_model_constants
  USE module_state_description
  USE module_data_radm2
  USE module_data_sorgam
  USE module_radm
  USE module_phot_mad
  USE module_ftuv_driver, only : ftuv_timestep_init
  USE module_data_soa_vbs, only: ldrog_vbs
  USE module_chem_utilities
  USE a_module_chem_utilities
  USE module_emissions_driver
  USE a_module_emissions_driver
  USE module_bioemi_simple
  USE module_input_tracer, only: set_tracer
  USE module_input_chem_data, only: last_chem_time, &
                                     get_last_gas,mozcart_lbc_set
  USE modal_aero_data, only: ntot_amode_cam_mam => ntot_amode
  USE module_cam_support, only: gas_pcnst => gas_pcnst_modal_aero,gas_pcnst_pos => gas_pcnst_modal_aero_pos, &
       pcnst =>pcnst_runtime, numgas_mam, cam_mam_aerosols
!For plumerise
  USE module_plumerise1
  USE mediation_pertmod_io , ONLY : find_nl_xtraj, read_xtraj
  USE esmf_timemod, ONLY : ESMF_TimeInc
  
  IMPLICIT NONE
  interface
     SUBROUTINE sum_pm_driver ( config_flags, &
          alt, chem, h2oaj, h2oai, &
          pm2_5_dry, pm2_5_water, pm2_5_dry_ec, pm10, &
          hoa_a01,hoa_a02,hoa_a03,hoa_a04, &
          bboa_a01,bboa_a02,bboa_a03,bboa_a04, &
          soa_a01,soa_a02,soa_a03,soa_a04, &
          bbsoa_a01,bbsoa_a02,bbsoa_a03,bbsoa_a04, &
          hsoa_a01,hsoa_a02,hsoa_a03,hsoa_a04, &
          biog_a01,biog_a02,biog_a03,biog_a04, &
          asmpsoa_a01,asmpsoa_a02,asmpsoa_a03,asmpsoa_a04, &
          arosoa_a01,arosoa_a02,arosoa_a03,arosoa_a04, &
          totoa_a01,totoa_a02,totoa_a03,totoa_a04, &
          hsoa_c,hsoa_o,bbsoa_c,bbsoa_o, &
          biog_v1,biog_v2,biog_v3,biog_v4, &
          ant_v1,ant_v2,ant_v3,ant_v4, &
          smpa_v1,smpbb_v1, &
          ids,ide, jds,jde, kds,kde, &
          ims,ime, jms,jme, kms,kme, &
          its,ite, jts,jte, kts,kte )
       USE module_configure
       USE module_gocart_aerosols, only: sum_pm_gocart
       IMPLICIT NONE
       INTEGER, INTENT(IN ) :: &
            ids,ide, jds,jde, kds,kde, &
            ims,ime, jms,jme, kms,kme, &
            its,ite, jts,jte, kts,kte
       REAL, DIMENSION( ims:ime, kms:kme, jms:jme, num_chem ), &
            INTENT(IN ) :: chem
       REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), &
            INTENT(IN ) :: alt
       REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), &
            OPTIONAL, &
            INTENT(IN ) :: h2oaj,h2oai
       REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), &
            OPTIONAL, &
            INTENT(OUT) :: pm2_5_dry,pm2_5_water,pm2_5_dry_ec,pm10, &
            hoa_a01,hoa_a02,hoa_a03,hoa_a04, &
            bboa_a01,bboa_a02,bboa_a03,bboa_a04, &
            soa_a01,soa_a02,soa_a03,soa_a04, &
            bbsoa_a01,bbsoa_a02,bbsoa_a03,bbsoa_a04, &
            hsoa_a01,hsoa_a02,hsoa_a03,hsoa_a04, &
            biog_a01,biog_a02,biog_a03,biog_a04, &
            arosoa_a01,arosoa_a02,arosoa_a03,arosoa_a04, &
            totoa_a01,totoa_a02,totoa_a03,totoa_a04, &
            hsoa_c,hsoa_o,bbsoa_c,bbsoa_o, &
            biog_v1,biog_v2,biog_v3,biog_v4, &
            ant_v1,ant_v2,ant_v3,ant_v4, &
            smpa_v1, &
            smpbb_v1, &
            asmpsoa_a01,asmpsoa_a02,asmpsoa_a03,asmpsoa_a04
       TYPE(grid_config_rec_type), INTENT(IN ) :: config_flags
     end SUBROUTINE sum_pm_driver
  end interface
  TYPE(DOMAIN), TARGET :: grid
   !  Definitions of dummy arguments to solve
# include <dummy_new_decl.inc>
  TYPE(GRID_CONFIG_REC_TYPE), INTENT(IN) :: config_flags
  INTEGER :: ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme&
&  , ips, ipe, jps, jpe, kps, kpe, its, ite, jts, jte, kts, kte
  INTEGER :: stepave, i, j, k, l, numgas, nv, n, nr, ktau, k_start, &
&  k_end, idf, jdf, kdf
  INTEGER :: ijulian
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:&
&  grid%em33) :: vcsulf_old, vcso2_old, vch2o2_old

  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:&
&  grid%em33, ldrog) :: vdrog3
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:&
&  grid%em33, ldrog_vbs) :: vdrog3_vbs
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:&
&  grid%em33) :: n2o5_het
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:&
&  grid%em33) :: p_phy, u_phy, v_phy, t_phy, dz8w, t8w, p8w, rho, rri, &
&  z_at_w, vvel, zmid, rh
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:&
&  grid%em33) :: a_p_phy, a_u_phy, a_v_phy, a_t_phy, a_dz8w, a_t8w, a_p8w, a_rho, a_rri&
&  , a_z_at_w, a_vvel, a_zmid, a_rh
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm33:grid%em33) :: pbl_h
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm33:grid%em33, 5) :: seasin&
&  , dustin
  REAL, DIMENSION(grid%sm32:grid%em32 - 1) :: ql, tl
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm33:grid%em33) :: rexnsfc, &
&  factrs, tot, tsfc
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:&
&  grid%em33, num_chem_ct) :: chem_old
  INTEGER, DIMENSION(num_chem_ct) :: chem_ct_indices
  TYPE(WRFU_TIMEINTERVAL) :: tmptimeinterval,run_interval
  REAL(kind=8) :: curr_secs
  INTEGER :: rc, runad
  REAL(kind=8) :: REAL_TIME_R8
  LOGICAL :: adapt_step_flag, do_chemstep, do_photstep
  REAL :: dayi, dpl, fice, frain, hour, plyr, qi, qr, qw, radt, times, &
&  wc, tdum, wmsk, rwmsk
  INTEGER :: ij
  INTEGER :: im, num_3d_m, ic, num_3d_c, num_3d_s
  INTEGER :: ijds, ijde
  INTEGER :: ksubt
  REAL :: chem_minval, dtstepc
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:&
&  grid%em33, numgas_mam) :: gas_aqfrac
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:&
&  grid%em33, ntot_amode_cam_mam) :: wetdens_ap
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:&
&  grid%em33) :: del_h2so4_gasprod
  REAL, DIMENSION(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:&
&  grid%em33, gas_pcnst_pos) :: dvmrdt_sv13d, dvmrcwdt_sv13d
  LOGICAL :: haveaer
  CHARACTER(len=1000) :: msg,message
  CHARACTER(len=256) :: current_date_char
  INTEGER :: current_month
  REAL*8 :: result1
  REAL*8 :: result2
  REAL :: tmp
  INTEGER :: branch
  INTEGER :: ad_to
  INTEGER :: ad_to0
  INTEGER :: ad_to1
  INTEGER :: ad_from
  INTEGER :: ad_to2
  INTEGER :: ad_from0
  INTEGER :: ad_to3
  INTEGER :: min7
  INTEGER :: min6
  INTEGER :: min5
  INTEGER :: min4
  INTEGER :: min3
  INTEGER :: min2
  INTEGER :: min8
  INTEGER :: min9
  INTEGER :: min10
  REAL :: tmpb
  LOGICAL :: do_plumerisefire
  adapt_step_flag = .true.
  ktau = grid%itimestep
  tmpTimeInterval = domain_get_current_time ( grid ) - domain_get_sim_start_time ( grid )
  curr_secs = REAL_TIME_R8(tmptimeinterval)
  run_interval = grid%stop_subtime - grid%start_subtime
  CALL WRFU_TimeIntervalGet( run_interval, S=runad, rc=rc )
  runad = abs(runad)
  curr_secs = REAL( runad, 8 ) + curr_secs !- REAL(grid%dt, 8)
  write(msg,*)'curr_secs = ',curr_secs
  CALL wrf_debug(16,TRIM(msg))

  ijulian = IFIX(grid%julian)
  do_photstep = .false.
  IF (ktau .EQ. 1) THEN
    do_photstep = .true.
  ELSE IF (adapt_step_flag) THEN
    result1 = REAL(grid%dt, 8)
    result2 = REAL(grid%photdt*60., 8)
    IF (grid%photdt .LE. 0 .OR. curr_secs + result1 + 0.01 .GE. INT(&
        curr_secs/result2+1, 8)*result2) do_photstep = .true.
  ELSE IF (MOD(ktau, grid%stepphot) .EQ. 0 .OR. grid%stepphot .EQ. 1) &
  THEN
    do_photstep = .true.
  END IF
  IF ( runad .EQ. INT( curr_secs, 8)) THEN !+ REAL(grid%dt, 8), 8) ) THEN
!DELETE-JJG
!  IF (ktau .EQ. 1) THEN
!DELETE-JJG
    dtstepc = grid%dt
  ELSE
    tmptimeinterval = DOMAIN_GET_CURRENT_TIME(grid) - LAST_CHEM_TIME(grid%id)
    dtstepc = abs(REAL(REAL_TIME_R8(tmptimeinterval), 4))
  END IF
  do_chemstep = .false.
  IF (ktau .EQ. 1) THEN
    do_chemstep = .true.
    grid%ktauc = 1
  ELSE IF (adapt_step_flag) THEN
    result1 = REAL(grid%dt, 8)
    result2 = REAL(grid%chemdt*60., 8)
    IF (grid%chemdt .LE. 0 .OR. curr_secs + result1 + 0.01 .GE. INT(&
        curr_secs/result2+1, 8)*result2) THEN
      do_chemstep = .true.
      grid%ktauc = grid%ktauc - 1
      last_chem_time(grid%id) = DOMAIN_GET_CURRENT_TIME(grid)
      CALL WRFU_TIMEGET(LAST_CHEM_TIME(grid%id), yy=grid%last_chem_time_year, mm=grid%&
                  last_chem_time_month, dd=grid%last_chem_time_day, h=&
                  grid%last_chem_time_hour, m=grid%last_chem_time_minute&
                  , s=grid%last_chem_time_second)
    END IF
  ELSE IF (MOD(ktau, grid%stepchem) .EQ. 0 .OR. grid%stepchem .EQ. 1) &
  THEN
    do_chemstep = .true.
    IF (ktau/grid%stepchem .LT. 1) THEN
      grid%ktauc = 1
    ELSE
      grid%ktauc = ktau/grid%stepchem
    END IF
  END IF
  CALL GET_IJK_FROM_GRID(grid, ids, ide, jds, jde, kds, kde, ims, ime, &
                   jms, jme, kms, kme, ips, ipe, jps, jpe, kps, kpe)
  CALL DOMAIN_CLOCK_GET(grid, current_timestr=current_date_char)
  READ(current_date_char(6:7), fmt='(I2)') current_month
  seasin(:, :, :) = 0.
  dustin(:, :, :) = 0.
  IF (config_flags%cu_diag .EQ. 0) grid%raincv_b(:, :) = grid%raincv(:, &
      :)
  num_3d_m = num_moist
  num_3d_c = num_chem
  num_3d_s = num_scalar
  numgas = GET_LAST_GAS(config_flags%chem_opt)
  CALL SET_TILES(grid, ids, ide, jds, jde, ips, ipe, jps, jpe)
  k_start = kps
  k_end = kpe
  IF (ids .GT. jds) THEN
    ijds = jds
  ELSE
    ijds = ids
  END IF
  IF (ide .LT. jde) THEN
    ijde = jde
  ELSE
    ijde = ide
  END IF
  chem_minval = epsilc
  SELECT CASE  (config_flags%chem_opt)
  CASE (RADM2)
    CALL WRF_DEBUG(15, 'calling radm2 from chem_driver')
    haveaer = .false.
  CASE (RADM2_KPP)
    CALL WRF_DEBUG(15, 'calling radm2_kpp from chem_driver')
    haveaer = .false.
  CASE (RADM2SORG)
    CALL WRF_DEBUG(15, &
             'calling radm2sorg aerosols driver from chem_driver')
    haveaer = .true.
  CASE (RADM2SORG_KPP)
    CALL WRF_DEBUG(15, &
             'calling radm2sorg aerosols driver from chem_driver')
    haveaer = .false.
  CASE (RADM2SORG_AQ)
    CALL WRF_DEBUG(15, &
             'calling radm2sorg_aq aerosols driver from chem_driver')
    haveaer = .true.
  CASE (RACMSORG_AQ)
    CALL WRF_DEBUG(15, &
             'calling racmsorg_aq aerosols driver from chem_driver')
    haveaer = .true.
  CASE (RADM2SORG_AQCHEM)
    CALL WRF_DEBUG(15, &
             'calling radm2sorg_aqchem aerosols driver from chem_driver'&
            )
    haveaer = .true.
  CASE (RACMSORG_AQCHEM_KPP)
    CALL WRF_DEBUG(15, &
             'calling racmsorg_aqchem_kpp aerosols driver from chem_driver')
    haveaer = .true.
  CASE (RACM_KPP)
    CALL WRF_DEBUG(15, 'calling racm_kpp from chem_driver')
  CASE (RACMPM_KPP)
    CALL WRF_DEBUG(15, 'calling racmpm_kpp from chem_driver')
    haveaer = .false.
  CASE (RACM_MIM_KPP)
    CALL WRF_DEBUG(15, 'calling racm_mim_kpp from chem_driver')
    haveaer = .false.
  CASE (RACM_ESRLSORG_KPP)
    CALL WRF_DEBUG(15, &
             'calling racmsorgesrl_kpp aerosols driver from chem_driver'&
            )
    haveaer = .false.
  CASE (RACMSORG_KPP)
    CALL WRF_DEBUG(15, &
             'calling racmsorg_kpp aerosols driver from chem_driver')
    haveaer = .false.
  CASE (RACM_SOA_VBS_KPP)
    CALL WRF_DEBUG(15, &
             'calling racm_soa_vbs_kpp aerosols driver from chem_driver'&
            )
    haveaer = .false.
  CASE (GOCART_SIMPLE)
    CALL WRF_DEBUG(15, &
             'calling only gocart aerosols driver from chem_driver')
    haveaer = .false.
  CASE (GOCARTRACM_KPP)
    CALL WRF_DEBUG(15, 'calling gocart and racm driver from chem_driver'&
            )
    haveaer = .false.
  CASE (GOCARTRADM2_KPP)
    CALL WRF_DEBUG(15, &
             'calling gocart and radmkpp driver from chem_driver')
    haveaer = .false.
  CASE (GOCARTRADM2)
    CALL WRF_DEBUG(15, 'calling gocart and radm driver from chem_driver'&
            )
    haveaer = .false.
  CASE (SAPRC99_KPP)
    CALL WRF_DEBUG(15, 'calling saprc99_kpp from chem_driver')
    haveaer = .false.
  CASE (CBMZ_MOSAIC_4BIN_VBS2_KPP)
    CALL WRF_DEBUG(15, &
             'calling cbmz_mosaic_4bin_vbs2_kpp from chem_driver')
    haveaer = .false.
  CASE (SAPRC99_MOSAIC_4BIN_VBS2_KPP)
    CALL WRF_DEBUG(15, &
             'calling saprc99_mosaic_4bin_vbs2_kpp from chem_driver')
    haveaer = .false.
  CASE (MOZART_MOSAIC_4BIN_VBS0_KPP)
    CALL WRF_DEBUG(15, &
             'calling mozart_mosaic_4bin_vbs0_kpp from chem_driver')
    haveaer = .true.
  CASE (CBMZSORG)
    CALL WRF_DEBUG(15, 'calling cbmzsorg aerosols from chem_driver')
    haveaer = .true.
  CASE (CBMZSORG_AQ)
    CALL WRF_DEBUG(15, 'calling cbmzsorg_aq aerosols from chem_driver')
    haveaer = .true.
  CASE (CBMZ)
    CALL WRF_DEBUG(15, 'calling cbmz from chem_driver')
    haveaer = .false.
  CASE (CBMZ_BB)
    CALL WRF_DEBUG(15, 'calling cbmz_bb from chem_driver')
    haveaer = .false.
  CASE (CBMZ_BB_KPP)
    CALL WRF_DEBUG(15, 'calling cbmz_bb_kpp from chem_driver')
    haveaer = .false.
  CASE (CBMZ_MOSAIC_KPP)
    CALL WRF_DEBUG(15, 'calling cbmz_mosaic_kpp from chem_driver')
    haveaer = .false.
  CASE (CBMZ_MOSAIC_4BIN)
    CALL WRF_DEBUG(15, &
             'calling cbmz_mosaic_4bin aerosols driver from chem_driver'&
            )
    haveaer = .true.
  CASE (CBMZ_MOSAIC_8BIN)
    CALL WRF_DEBUG(15, &
             'calling cbmz_mosaic_8bin aerosols driver from chem_driver'&
            )
    haveaer = .true.
  CASE (CBMZ_MOSAIC_4BIN_AQ)
    CALL WRF_DEBUG(15, &
          'calling cbmz_mosaic_4bin_aq aerosols driver from chem_driver'&
            )
    haveaer = .true.
  CASE (CBMZ_MOSAIC_8BIN_AQ)
    CALL WRF_DEBUG(15, &
          'calling cbmz_mosaic_8bin_aq aerosols driver from chem_driver'&
            )
    haveaer = .true.
  CASE (CBMZ_MOSAIC_DMS_4BIN)
    CALL WRF_DEBUG(15, &
         'calling cbmz_mosaic_dms_4bin aerosols driver from chem_driver'&
            )
    haveaer = .true.
  CASE (CBMZ_MOSAIC_DMS_8BIN)
    CALL WRF_DEBUG(15, &
         'calling cbmz_mosaic_dms_8bin aerosols driver from chem_driver'&
            )
    haveaer = .true.
  CASE (CBMZ_MOSAIC_DMS_4BIN_AQ)
    CALL WRF_DEBUG(15, &
      'calling cbmz_mosaic_dms_4bin_aq aerosols driver from chem_driver'&
            )
    haveaer = .true.
  CASE (CBMZ_MOSAIC_DMS_8BIN_AQ)
    CALL WRF_DEBUG(15, &
      'calling cbmz_mosaic_dms_8bin_aq aerosols driver from chem_driver'&
            )
    haveaer = .true.
  CASE (MOZART_KPP)
    CALL WRF_DEBUG(15, 'calling mozart driver from chem_driver')
  CASE (MOZCART_KPP)
    CALL WRF_DEBUG(15, 'calling mozcart driver from chem_driver')
  CASE (CHEM_TRACER, CHEM_TRACE2)
    CALL WRF_DEBUG(15, &
          'tracer mode: only doing emissions and dry dep in chem_driver'&
            )
  CASE (CHEM_VOLC)
    CALL WRF_DEBUG(15, 'Full Volcanic Ash mode: doing emissions (SO2 + A&
SH), settling, and subgrid transport in chem_driver')
  CASE (CHEM_VOLC_4BIN)
    CALL WRF_DEBUG(15, '4bin Volcanic Ash mode: doing emissions (ASH), s&
ettling, and subgrid transport in chem_driver')
  CASE (CHEM_VASH)
    CALL WRF_DEBUG(15, 'Volcanic Ash mode: only doing emissions, settlin&
g, and subgrid transport in chem_driver')
  CASE (DUST)
    CALL WRF_DEBUG(15, 'Dust only mode: only doing emissions, settling, &
and subgrid transport chem_driver')
  CASE (CO2_TRACER, GHG_TRACER)
    CALL WRF_DEBUG(15, &
             'Greenhouse gas mode: fluxes and transport of GHG')
  CASE DEFAULT
    IF (config_flags%tracer_opt .GT. 0) THEN
      CALL WRF_DEBUG(15, 'only doing tracer transport in chem_driver')
    ELSE
      CALL WRF_DEBUG(15, 'calling chem_opt=? from chem_driver')
    END IF
  END SELECT
  SELECT CASE  (config_flags%tracer_opt)
  CASE (TRACER_SMOKE)
    CALL WRF_DEBUG(15, 'tracer mode: 1 tracer for fires')
  CASE (TRACER_TEST1)
    CALL WRF_DEBUG(15, 'tracer mode: 8 tracers')
  CASE (TRACER_TEST2)
    CALL WRF_DEBUG(15, 'tracer mode: 8 tracers')
  CASE (TRACER_TEST3)
    CALL WRF_DEBUG(15, 'tracer mode: 10 tracers')
  CASE DEFAULT
    CALL WRF_DEBUG(15, 'calling chem_opt=? from chem_driver')
  END SELECT

  IF (((config_flags%chem_opt .EQ. cbmz_cam_mam3_noaq .OR. config_flags%&
&      chem_opt .EQ. cbmz_cam_mam3_aq) .OR. config_flags%chem_opt .EQ. &
&      cbmz_cam_mam7_noaq) .OR. config_flags%chem_opt .EQ. &
&      cbmz_cam_mam7_aq) THEN
    IF (numgas_mam .LT. numgas) WRITE(msg, *) 'CHEM_DRIVER - NUMGAS_MAM &
&is should be equal to numgas (check chemics_init.F),', ' numgas_mam=', &
&                                numgas_mam, ' and numgas=', numgas
    IF (.NOT.cam_mam_aerosols) WRITE(msg, *) 'CHEM_DRIVER - cam_mam_aero&
&sol should be TRUE (check module_physics_init.F),', &
&                               ' module_cam_mam_aerosol=', &
&                               cam_mam_aerosols
  END IF
  DO nv=1,num_chem
    DO j=jps,jpe
      DO k=kps,kpe
        DO i=ips,ipe
          IF (chem(i, k, j, nv) .LT. chem_minval) THEN
            chem(i, k, j, nv) = chem_minval
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
            chem(i, k, j, nv) = chem(i, k, j, nv)
          END IF
        END DO
      END DO
    END DO
  END DO
  SELECT CASE  (config_flags%chem_opt) 
  CASE (radm2sorg, radm2sorg_aq, radm2sorg_aqchem, radm2sorg_kpp, &
&  racm_esrlsorg_kpp, racmsorg_aq, racmsorg_kpp, racmsorg_aqchem_kpp, &
&  racm_soa_vbs_kpp) 
    DO j=jps,jpe
      DO k=kps,kpe
        DO i=ips,ipe
          IF (chem(i, k, j, p_nu0) .LT. 1.e07) THEN
            chem(i, k, j, p_nu0) = 1.e7
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
    END DO
    CALL PUSHCONTROL2B(1)
  CASE (cbmz_mosaic_4bin_vbs2_kpp, saprc99_kpp, &
&  saprc99_mosaic_4bin_vbs2_kpp) 
    DO j=jps,jpe
      DO k=kps,kpe
        DO i=ips,ipe
          chem(i, k, j, p_ch4) = 1.74
        END DO
      END DO
    END DO
    CALL PUSHCONTROL2B(2)
  CASE DEFAULT
    CALL PUSHCONTROL2B(0)
  END SELECT
  IF (jde - 1 .GT. jpe) THEN
    min8 = jpe
  ELSE
    min8 = jde - 1
  END IF
  DO j=jps,min8
    DO k=kps,kpe
      IF (ide - 1 .GT. ipe) THEN
        min2 = ipe
      ELSE
        min2 = ide - 1
      END IF
      DO i=ips,min2
        vvel(i, k, j) = grid%w_2(i, k, j)
      END DO
    END DO
  END DO
  IF (jde - 1 .GT. jpe) THEN
    min3 = jpe
  ELSE
    min3 = jde - 1
  END IF
  DO j=jps,min3
    IF (kde - 1 .GT. kpe) THEN
      min4 = kpe
    ELSE
      min4 = kde - 1
    END IF
    DO k=kps,min4
      IF (ide - 1 .GT. ipe) THEN
        min5 = ipe
      ELSE
        min5 = ide - 1
      END IF
      DO i=ips,min5
        rri(i, k, j) = grid%alt(i, k, j)
      END DO
      CALL PUSHINTEGER4(i - 1)
    END DO
    CALL PUSHINTEGER4(k - 1)
  END DO

!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, its, ite, jts, jte )
   DO ij = 1 , grid%num_tiles
       its = grid%i_start(ij)
       ite = min(grid%i_end(ij),ide-1)
       jts = grid%j_start(ij)
       jte = min(grid%j_end(ij),jde-1)

       kts=k_start
       kte=min(k_end,kde-1)

    CALL PUSHREAL8ARRAY(dz8w, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL PUSHREAL8ARRAY(t_phy, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL PUSHREAL8ARRAY(p8w, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL PUSHREAL8ARRAY(rho, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL PUSHREAL8ARRAY(u_phy, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL PUSHREAL8ARRAY(v_phy, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL PUSHREAL8ARRAY(p_phy, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL PUSHREAL8ARRAY(t8w, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL PUSHREAL8ARRAY(z_at_w, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL PUSHREAL8ARRAY(rh, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL PUSHREAL8ARRAY(grid%z, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))

    CALL CHEM_PREP(config_flags, grid%u_2, grid%v_2, &
&             grid%p, grid%pb, grid%alt, grid%ph_2, &
&             grid%phb, grid%t_2, moist, num_3d_m, rho, p_phy, &
&             u_phy, v_phy, p8w, t_phy, t8w, grid%z, z_at_w, dz8w, &
&             rh, grid%fnm, grid%fnp, ids, ide, jds, jde, kds, kde, ims, &
&             ime, jms, jme, kms, kme, its, ite, jts, jte, k_start, k_end&
&            )
  END DO
!$OMP END PARALLEL DO
  IF (jde - 1 .GT. jpe) THEN
    min9 = jpe
  ELSE
    min9 = jde - 1
  END IF
  DO j=jps,min9
    DO k=kps,kpe
      IF (ide - 1 .GT. ipe) THEN
        min10 = ipe
      ELSE
        min10 = ide - 1
      END IF
      DO i=ips,min10
        zmid(i, k, j) = grid%z(i, k, j)
      END DO
      CALL PUSHINTEGER4(i - 1)
    END DO
  END DO
!$OMP PARALLEL DO &
!$OMP PRIVATE ( ij, its, ite, jts, jte )
chem_tile_loop_ad:DO ij=1,grid%num_tiles
       its = grid%i_start(ij)
       ite = min(grid%i_end(ij),ide-1)
       jts = grid%j_start(ij)
       jte = min(grid%j_end(ij),jde-1)
       
       kts=k_start
       kte=min(k_end,kde-1)

    IF (config_flags%emiss_inpt_opt .GT. 0 .OR. config_flags%dust_opt &
&        .GT. 0) THEN

      do_plumerisefire = .false.
      IF ( config_flags%biomass_burn_opt == BIOMASSB_MOZC .OR. &
           config_flags%biomass_burn_opt == BIOMASSB_MOZ  .OR. &
           config_flags%biomass_burn_opt == BIOMASSB_GHG  .OR. &
           config_flags%biomass_burn_opt == BIOMASSB &
           .OR. config_flags%biomass_burn_opt == WRFPLUS_BB &
            ) then
        IF ( ktau==1 ) then
           do_plumerisefire = .false.
        ELSE IF ( adapt_step_flag ) THEN
           IF ( (grid%plumerisefire_frq<=0) .or. &
                ( curr_secs+0.01 >= &
                ( FLOOR( (curr_secs - real(grid%dt,8))/real(grid%plumerisefire_frq*60.,8)+1.0D0 )*real(grid%plumerisefire_frq*60.,8) ) ) &
                ) then
              do_plumerisefire = .true.
           ENDIF
        ELSE IF ( (MOD(ktau,grid%stepfirepl)==0) .or. (grid%stepfirepl==1) ) THEN
           do_plumerisefire = .true.
        ENDIF
      ENDIF

      IF(do_plumerisefire) THEN
!The following PUSH calls must be made for any variable modified in chem_driver
! that is also part of the trajectory. Keep this in mind when adding aerosl-cloud
! interactions -JJG
         CALL PUSHREAL8ARRAY(chem, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1)*num_chem)
         CALL PUSHREAL8ARRAY(tracer, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1)*num_tracer)

         CALL PUSHREAL8ARRAY(zmid, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL PUSHREAL8ARRAY(grid%u_2, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL PUSHREAL8ARRAY(grid%v_2, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL PUSHREAL8ARRAY(grid%w_2, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL PUSHREAL8ARRAY(grid%p, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL PUSHREAL8ARRAY(grid%alt, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL PUSHREAL8ARRAY(grid%ph_2, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL PUSHREAL8ARRAY(grid%t_2, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL PUSHREAL8ARRAY(grid%moist(:,:,:,p_qv), (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))


!!!!Then calculate remainder of physics variables from end of solve_em call
         CALL domain_clock_set( grid, time_step_seconds=-60*grid%plumerisefire_frq+config_flags%time_step )
         grid%domain_clock%clockint%CurrTime =  ESMF_TimeInc (grid%domain_clock%clockint%CurrTime, &
                                grid%domain_clock%clockint%TimeStep )
         CALL domain_clock_get ( grid, current_timestr=message )
         CALL find_nl_xtraj (message) !Points xtraj_pointer to correct time
         CALL read_xtraj(message) !Reads same time as above, then advances xtraj_pointer
         CALL CHEM_PREP(config_flags, grid%u_2, grid%v_2, &
                  grid%p, grid%pb, grid%alt, grid%ph_2, &
                  grid%phb, grid%t_2, moist, num_3d_m, rho, p_phy, &
                  u_phy, v_phy, p8w, t_phy, t8w, grid%z, z_at_w, dz8w, &
                  rh, grid%fnm, grid%fnp, ids, ide, jds, jde, kds, kde, ims, &
                  ime, jms, jme, kms, kme, its, ite, jts, jte, k_start, k_end)
!!!Have to place this after CHEM_PREP after grid%z is recalculated from the correct time step.
         do j=jps,min(jde-1,jpe)
            do k=kps,kpe
               do i=ips,min(ide-1,ipe)
                 vvel(i,k,j)=grid%w_2(i,k,j)
                 zmid(i,k,j)=grid%z(i,k,j)
               enddo
            enddo
         enddo

! Calculate plumerise
         CALL wrf_debug(15,'fire emissions: calling plumerise')
         write(0,*)ktau,grid%stepfirepl
         CALL plumerise_driver (grid%id,ktau,grid%dt,                 &
           ebu,ebu_in,                                                 &
           grid%mean_fct_agtf,grid%mean_fct_agef,                      &
           grid%mean_fct_agsv,grid%mean_fct_aggr,                      &
           grid%firesize_agtf,grid%firesize_agef,                      &
           grid%firesize_agsv,grid%firesize_aggr,                      &
           config_flags, t_phy,moist,                                  &
           rho,vvel,u_phy,v_phy,p_phy,                                 &
           emis_ant,z_at_w,zmid,config_flags%scale_fire_emiss,         &
           ids,ide, jds,jde, kds,kde,                                  &
           ims,ime, jms,jme, kms,kme,                                  &
           its,ite, jts,jte, kts,kte                                    )


! Restore physics variables to current time step (values after solve_em and after chem_driver)
         CALL domain_clock_set( grid, time_step_seconds=60*grid%plumerisefire_frq-config_flags%time_step )
         grid%domain_clock%clockint%CurrTime = ESMF_TimeInc (grid%domain_clock%clockint%CurrTime, &
                            grid%domain_clock%clockint%TimeStep )
         CALL domain_clock_get ( grid, current_timestr=message )
         CALL find_nl_xtraj (message) !Points xtraj_pointer to correct time
         CALL read_xtraj(message) !Reads same time as above, then advances xtraj_pointer
         CALL domain_clock_set( grid, time_step_seconds=-1*config_flags%time_step )

         CALL POPREAL8ARRAY(grid%moist(:,:,:,p_qv), (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL POPREAL8ARRAY(grid%t_2, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL POPREAL8ARRAY(grid%ph_2, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL POPREAL8ARRAY(grid%alt, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL POPREAL8ARRAY(grid%p, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL POPREAL8ARRAY(grid%w_2, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL POPREAL8ARRAY(grid%v_2, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL POPREAL8ARRAY(grid%u_2, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
         CALL POPREAL8ARRAY(zmid, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))

         CALL POPREAL8ARRAY(tracer, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1)*num_tracer)
         CALL POPREAL8ARRAY(chem, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1)*num_chem)

         do j=jps,min(jde-1,jpe)
            do k=kps,kpe
               do i=ips,min(ide-1,ipe)
                 vvel(i,k,j)=grid%w_2(i,k,j)
!                 zmid(i,k,j)=grid%z(i,k,j)
               enddo
            enddo
         enddo

         CALL CHEM_PREP(config_flags, grid%u_2, grid%v_2, &
                  grid%p, grid%pb, grid%alt, grid%ph_2, &
                  grid%phb, grid%t_2, moist, num_3d_m, rho, p_phy, &
                  u_phy, v_phy, p8w, t_phy, t8w, grid%z, z_at_w, dz8w, &
                  rh, grid%fnm, grid%fnp, ids, ide, jds, jde, kds, kde, ims, &
                  ime, jms, jme, kms, kme, its, ite, jts, jte, k_start, k_end)
      ENDIF

      CALL PUSHREAL8ARRAY(ebu, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1)*num_ebu)
      CALL PUSHREAL8ARRAY(chem, (grid%em31-grid%sm31+1)*&
                  (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1)*num_chem)
      CALL EMISSIONS_DRIVER(grid%id,ktau,grid%dt,grid%DX, &
              adapt_step_flag, curr_secs, &
              grid%plumerisefire_frq,grid%stepfirepl, &
              grid%bioemdt,grid%stepbioe, &
              config_flags, &
              grid%gmt,ijulian,rri,t_phy,moist,p8w,t8w,u_phy,v_phy,vvel, &
              grid%e_bio,p_phy,chem,rho,dz8w,grid%ne_area,emis_ant,emis_vol,grid%tsk, &
              grid%erod,g,emis_seas,emis_dust,tracer, &
              scaleant,grid%scaleant_frq,grid%stepscaleant,grid%num_ant_steps, &
              scalebb,grid%scalebb_frq,grid%stepscalebb,grid%num_bb_steps, &
              grid%check_count, grid%checkpoint_interval,                            &
              ebu , ebu_in,grid%mean_fct_agtf,grid%mean_fct_agef,grid%mean_fct_agsv, &
              grid%mean_fct_aggr,grid%firesize_agtf, &
              grid%firesize_agef,grid%firesize_agsv,grid%firesize_aggr, &
              grid%u10,grid%v10,grid%ivgtyp,grid%isltyp,grid%gsw,grid%vegfra,grid%rmol, &
              grid%ust,grid%znt,grid%dms_0,grid%erup_beg,grid%erup_end, &
              grid%xland,grid%xlat,grid%xlong, &
              z_at_w,zmid,grid%smois,dustin,seasin, &
              grid%sebio_iso,grid%sebio_oli,grid%sebio_api,grid%sebio_lim, &
              grid%sebio_xyl,grid%sebio_hc3,grid%sebio_ete,grid%sebio_olt, &
              grid%sebio_ket,grid%sebio_ald,grid%sebio_hcho,grid%sebio_eth, &
              grid%sebio_ora2,grid%sebio_co,grid%sebio_nr, &
              grid%sebio_sesq,grid%sebio_mbo, &
              grid%noag_grow,grid%noag_nongrow,grid%nononag,grid%slai, &
              grid%ebio_iso,grid%ebio_oli,grid%ebio_api,grid%ebio_lim,grid%ebio_xyl, &
              grid%ebio_hc3,grid%ebio_ete,grid%ebio_olt,grid%ebio_ket,grid%ebio_ald, &
              grid%ebio_hcho,grid%ebio_eth,grid%ebio_ora2,grid%ebio_co,grid%ebio_nr, &
              grid%ebio_no,grid%ebio_sesq,grid%ebio_mbo, &
              grid%ebio_c10h16,grid%ebio_tol,grid%ebio_bigalk, &
              grid%ebio_ch3oh,grid%ebio_acet,grid%ebio_nh3,grid%ebio_no2, &
              grid%ebio_c2h5oh,grid%ebio_ch3cooh,grid%ebio_mek,grid%ebio_bigene, &
              grid%ebio_c2h6,grid%ebio_c2h4,grid%ebio_c3h6,grid%ebio_c3h8,grid%ebio_so2, &
              grid%ebio_dms, &
              grid%ebio_alk3, grid%ebio_alk4, grid%ebio_alk5, grid%ebio_ole1, grid%ebio_ole2, &
              grid%ebio_aro1, grid%ebio_aro2, grid%ebio_ccho, grid%ebio_meoh, &
              grid%ebio_ethene, grid%ebio_hcooh, grid%ebio_terp, grid%ebio_bald, &
              grid%ebio_cco_oh, grid%ebio_rco_oh, &
              grid%clayfrac,grid%sandfrac,grid%dust_alpha,grid%dust_gamma,grid%dust_smtune,&
              grid%snowh,grid%zs, &
              grid%soilctop, grid%ust_t, grid%rough_cor, grid%smois_cor,                  &
              grid%ebio_c5h8,grid%ebio_apinene,grid%ebio_bpinene,grid%ebio_toluene,        &
              grid%ebio_ch3cho,grid%ebio_ch3co2h,grid%ebio_tbut2ene,                      &
              grid%ebio_c2h5cho,grid%ebio_nc4h10,                                         &
              grid%T2,grid%swdown, &
              grid%nmegan,grid%EFmegan, &
              grid%msebio_isop, &
              grid%mlai, &
              grid%pftp_bt, grid%pftp_nt, grid%pftp_sb, grid%pftp_hb, &
              grid%mtsa, &
              grid%mswdown, &
              grid%mebio_isop,grid%mebio_apin,grid%mebio_bpin, grid%mebio_bcar, &
              grid%mebio_acet,grid%mebio_mbo,grid%mebio_no, &
              current_month, &
              grid%ht, grid%refl_10cm, grid%ic_flashrate, grid%cg_flashrate, &
              emis_aircraft, &
              vprm_in,grid%rad_vprm,grid%lambda_vprm, &
              grid%alpha_vprm,grid%resp_vprm,grid%xtime, &
              grid%TSLB, wet_in,grid%RAINC,grid%RAINNC, &
              grid%potevp,grid%SFCEVP,grid%LU_INDEX, &
              grid%biomt_par,grid%emit_par,grid%ebio_co2oce, &
              eghg_bio, &
              ids,ide, jds,jde, kds,kde, &
              ims,ime, jms,jme, kms,kme, &
              its,ite,jts,jte,kts,kte)

      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (do_chemstep .AND. config_flags%chem_opt .NE. chem_tracer .AND. &
&        config_flags%chem_opt .NE. chem_vash .AND. config_flags%chem_opt&
&        .NE. chem_volc .AND. config_flags%chem_opt .NE. chem_volc_4bin &
&        .AND. config_flags%chem_opt .NE. dust .AND. config_flags%&
&        chem_opt .NE. chem_trace2 .AND. config_flags%chem_opt .NE. &
&        co2_tracer .AND. config_flags%chem_opt .NE. ghg_tracer) THEN
      IF (config_flags%gaschem_onoff .GT. 0) THEN
        CALL PUSHREAL8ARRAY(chem, (grid%em31-grid%sm31+1)*(grid%em32-&
&                      grid%sm32+1)*(grid%em33-grid%sm33+1)*num_chem)
        CALL MECHANISM_DRIVER(grid%id,curr_secs,ktau,grid%dt,grid%ktauc,dtstepc,config_flags, &
              grid%gmt,ijulian,t_phy,moist,p8w,t8w,grid%gd_cldfr,                 &
              p_phy,chem,rho,dz8w,grid%dx,g,                                          &
              zmid,z_at_w,grid%xlat,grid%xlong,                                       &
              vdrog3,vcsulf_old,vcso2_old,vch2o2_old,grid%ttday,grid%tcosz,           &
              grid%ph_macr,grid%ph_o31d,grid%ph_o33p,grid%ph_no2,grid%ph_no3o2,       &
              grid%ph_no3o,grid%ph_hno2,grid%ph_hno3,grid%ph_hno4,grid%ph_h2o2,       &
              grid%ph_ch2or,grid%ph_ch2om,grid%ph_ch3cho,grid%ph_ch3coch3,            &
              grid%ph_ch3coc2h5,grid%ph_hcocho,grid%ph_ch3cocho,grid%ph_hcochest,     &
              grid%ph_ch3o2h,grid%ph_ch3coo2h,grid%ph_ch3ono2,grid%ph_hcochob,        &
              grid%ph_n2o5,grid%ph_o2,grid%backg_oh,grid%backg_h2o2,grid%backg_no3,   &
              grid%addt,grid%addx,grid%addc,grid%etep,                                &
              grid%oltp,grid%olip,grid%cslp,grid%limp,grid%hc5p,grid%hc8p,grid%tolp,  &
              grid%xylp,grid%apip,grid%isop,grid%hc3p,grid%ethp,grid%o3p,grid%tco3,   &
              grid%mo2,grid%o1d,grid%olnn,grid%rpho,grid%xo2,                         &
              grid%ketp,grid%olnd,                                                    &
              ids,ide, jds,jde, kds,kde,                                              &
              ims,ime, jms,jme, kms,kme,                                              &
              its,ite,jts,jte,kts,kte        )
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (config_flags%aerchem_onoff .GT. 0) THEN
        CALL PUSHREAL8ARRAY(chem, (grid%em31-grid%sm31+1)*(grid%em32-&
&                      grid%sm32+1)*(grid%em33-grid%sm33+1)*num_chem)
        CALL AEROSOLS_DRIVER (grid%id,curr_secs,ktau,grid%dt,grid%ktauc,              &
              config_flags,dtstepc,grid%dx,                                            &
              rri,t_phy,moist,grid%aerwrf,p8w,t8w,                                    &
              p_phy,chem,rho,dz8w, rh,                                                & 
              zmid,z_at_w,pbl_h,grid%cldfra,grid%cldfra_mp_all,grid%vbs_nbin,         &
              grid%h2oaj,grid%h2oai,grid%nu3,grid%ac3,grid%cor3,grid%asulf,           &
              grid%ahno3,grid%anh3,grid%cvaro1,grid%cvaro2,grid%cvalk1,grid%cvole1,   &
              grid%cvapi1,grid%cvapi2,grid%cvlim1,grid%cvlim2,vcsulf_old,             &
              vdrog3,vdrog3_vbs,grid%br_rto,grid%dgnum4d,grid%dgnumwet4d,wetdens_ap,  &
              del_h2so4_gasprod,grid%dvmrdt_sv13d,grid%dvmrcwdt_sv13d,                &
              grid%is_CAMMGMP_used,                                                   &!BSINGH:01/31/2013: Added is_CAMMGMP_used for cam_mam_aerchem_driver
              ids,ide, jds,jde, kds,kde,                                              &
              ims,ime, jms,jme, kms,kme,                                              &
              its,ite,jts,jte,kts,kte                                                 )

        CALL PUSHCONTROL2B(0)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(2)
    END IF
    CALL PUSHREAL8ARRAY(grid%pm10, (grid%em31-grid%sm31+1)*&
                        (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
!    CALL PUSHREAL8ARRAY(grid%pm2_5_dry_ec, (grid%em31-grid%sm31+1)*(&
!&                  grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
    CALL PUSHREAL8ARRAY(grid%pm2_5_dry, (grid%em31-grid%sm31+1)*&
                        (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
    CALL SUM_PM_DRIVER ( config_flags,                                              &
           rri, chem, grid%h2oaj, grid%h2oai,                                         &
           grid%pm2_5_dry, grid%pm2_5_water, grid%pm2_5_dry_ec, grid%pm10,            &
           grid% hoa_a01,grid%hoa_a02,grid%hoa_a03,grid%hoa_a04,                      &
           grid%bboa_a01,grid%bboa_a02,grid%bboa_a03,grid%bboa_a04,                   &
           grid%soa_a01,grid%soa_a02,grid%soa_a03,grid%soa_a04,                       &
           grid%bbsoa_a01,grid%bbsoa_a02,grid%bbsoa_a03,grid%bbsoa_a04,               &
           grid%hsoa_a01,grid%hsoa_a02,grid%hsoa_a03,grid%hsoa_a04,                   &
           grid%biog_a01,grid%biog_a02,grid%biog_a03,grid%biog_a04,                   &
           grid%asmpsoa_a01,grid%asmpsoa_a02,grid%asmpsoa_a03,grid%asmpsoa_a04,                   &
           grid%arosoa_a01,grid%arosoa_a02,grid%arosoa_a03,grid%arosoa_a04,           &
           grid%totoa_a01,grid%totoa_a02,grid%totoa_a03,grid%totoa_a04,               &
           grid%hsoa_c,grid%hsoa_o,grid%bbsoa_c,grid%bbsoa_o,                         &
           grid%biog_v1,grid%biog_v2,grid%biog_v3,grid%biog_v4,                       &
           grid%ant_v1,grid%ant_v2,grid%ant_v3,grid%ant_v4,                           &
           grid%smpa_v1,grid%smpbb_v1,                           &
             ids,ide, jds,jde, kds,kde,                                               &
             ims,ime, jms,jme, kms,kme,                                               &
             its,ite, jts,jte, kts,kte             )
    DO nv=1,num_chem
      ad_from0 = jts
      DO j=ad_from0,jte
        ad_from = its
        DO i=ad_from,ite
          tmp = chem(i, kte, j, nv)
          CALL PUSHREAL8(chem(i, k_end, j, nv))
          chem(i, k_end, j, nv) = tmp
        END DO
        CALL PUSHINTEGER4(i - 1)
        CALL PUSHINTEGER4(ad_from)
      END DO
      CALL PUSHINTEGER4(j - 1)
      CALL PUSHINTEGER4(ad_from0)
    END DO
    a_v_phy = 0.0_8
    a_zmid = 0.0_8
    a_t_phy = 0.0_8
    a_p_phy = 0.0_8
    a_vvel = 0.0_8
    a_u_phy = 0.0_8
    a_z_at_w = 0.0_8
    a_rho = 0.0_8
    a_rri = 0.0_8
    a_dz8w = 0.0_8
    a_rh = 0.0_8
    a_p8w = 0.0_8
    a_t8w = 0.0_8

    DO nv=num_chem,1,-1
      CALL POPINTEGER4(ad_from0)
      CALL POPINTEGER4(ad_to3)
      DO j=ad_to3,ad_from0,-1
        CALL POPINTEGER4(ad_from)
        CALL POPINTEGER4(ad_to2)
        DO i=ad_to2,ad_from,-1
          CALL POPREAL8(chem(i, k_end, j, nv))
          tmpb = a_chem(i, k_end, j, nv)
          a_chem(i, k_end, j, nv) = 0.0_8
          a_chem(i, kte, j, nv) = a_chem(i, kte, j, nv) + tmpb
        END DO
      END DO
    END DO
    CALL POPREAL8ARRAY(grid%pm2_5_dry, (grid%em31-grid%sm31+1)*&
                   (grid%em32-grid%sm32+1)*(grid%em33-grid%sm33+1))
    CALL POPREAL8ARRAY(grid%pm10, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                   (grid%em33-grid%sm33+1))
    CALL A_SUM_PM_DRIVER ( config_flags,                                              &
           rri, a_rri, chem, a_chem, grid%h2oaj, grid%h2oai,                          &
           grid%pm2_5_dry, grid%a_pm2_5_dry, grid%pm2_5_water,                        &
           grid%pm2_5_dry_ec, grid%a_pm2_5_dry_ec, grid%pm10, grid%a_pm10,            &
           grid%hoa_a01,grid%hoa_a02,grid%hoa_a03,grid%hoa_a04,                      &
           grid%bboa_a01,grid%bboa_a02,grid%bboa_a03,grid%bboa_a04,                   &
           grid%soa_a01,grid%soa_a02,grid%soa_a03,grid%soa_a04,                       &
           grid%bbsoa_a01,grid%bbsoa_a02,grid%bbsoa_a03,grid%bbsoa_a04,               &
           grid%hsoa_a01,grid%hsoa_a02,grid%hsoa_a03,grid%hsoa_a04,                   &
           grid%biog_a01,grid%biog_a02,grid%biog_a03,grid%biog_a04,                   &
           grid%asmpsoa_a01,grid%asmpsoa_a02,grid%asmpsoa_a03,grid%asmpsoa_a04,                   &
           grid%arosoa_a01,grid%arosoa_a02,grid%arosoa_a03,grid%arosoa_a04,           &
           grid%totoa_a01,grid%totoa_a02,grid%totoa_a03,grid%totoa_a04,               &
           grid%hsoa_c,grid%hsoa_o,grid%bbsoa_c,grid%bbsoa_o,                         &
           grid%biog_v1,grid%biog_v2,grid%biog_v3,grid%biog_v4,                       &
           grid%ant_v1,grid%ant_v2,grid%ant_v3,grid%ant_v4,                           &
           grid%smpa_v1,grid%smpbb_v1,                           &
             ids,ide, jds,jde, kds,kde,                                               &
             ims,ime, jms,jme, kms,kme,                                               &
             its,ite, jts,jte, kts,kte             )
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8ARRAY(chem, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                               (grid%em33-grid%sm33+1)*num_chem)
      CALL A_AEROSOLS_DRIVER (grid%id,curr_secs,ktau,grid%dt,grid%ktauc,              &
              config_flags,dtstepc,grid%dx,                                            &
              rri,t_phy,moist,grid%aerwrf,p8w,t8w,                                    &
              p_phy,chem,a_chem,rho,dz8w, rh,                                                & 
              zmid,z_at_w,pbl_h,grid%cldfra,grid%cldfra_mp_all,grid%vbs_nbin,         &
              grid%h2oaj,grid%h2oai,grid%nu3,grid%ac3,grid%cor3,grid%asulf,           &
              grid%ahno3,grid%anh3,grid%cvaro1,grid%cvaro2,grid%cvalk1,grid%cvole1,   &
              grid%cvapi1,grid%cvapi2,grid%cvlim1,grid%cvlim2,vcsulf_old,             &
              vdrog3,vdrog3_vbs,grid%br_rto,grid%dgnum4d,grid%dgnumwet4d,wetdens_ap,  &
              del_h2so4_gasprod,grid%dvmrdt_sv13d,grid%dvmrcwdt_sv13d,                &
              grid%is_CAMMGMP_used,                                                   &!BSINGH:01/31/2013: Added is_CAMMGMP_used for cam_mam_aerchem_driver
              ids,ide, jds,jde, kds,kde,                                              &
              ims,ime, jms,jme, kms,kme,                                              &
              its,ite,jts,jte,kts,kte                                                 )
    ELSE IF (branch .NE. 1) THEN
      GOTO 100
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      CALL POPREAL8ARRAY(chem, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                               (grid%em33-grid%sm33+1)*num_chem)
      CALL A_MECHANISM_DRIVER(grid%id,curr_secs,ktau,grid%dt,grid%ktauc,dtstepc,config_flags, &
              grid%gmt,ijulian,t_phy,a_t_phy,moist,p8w,t8w,grid%gd_cldfr,                 &
              p_phy,chem,a_chem,rho,a_rho,dz8w,grid%dx,g,                             &
              zmid,z_at_w,grid%xlat,grid%xlong,                                       &
              vdrog3,vcsulf_old,vcso2_old,vch2o2_old,grid%ttday,grid%tcosz,           &
              grid%ph_macr,grid%ph_o31d,grid%ph_o33p,grid%ph_no2,grid%ph_no3o2,       &
              grid%ph_no3o,grid%ph_hno2,grid%ph_hno3,grid%ph_hno4,grid%ph_h2o2,       &
              grid%ph_ch2or,grid%ph_ch2om,grid%ph_ch3cho,grid%ph_ch3coch3,            &
              grid%ph_ch3coc2h5,grid%ph_hcocho,grid%ph_ch3cocho,grid%ph_hcochest,     &
              grid%ph_ch3o2h,grid%ph_ch3coo2h,grid%ph_ch3ono2,grid%ph_hcochob,        &
              grid%ph_n2o5,grid%ph_o2,grid%backg_oh,grid%backg_h2o2,grid%backg_no3,   &
              grid%addt,grid%addx,grid%addc,grid%etep,                                &
              grid%oltp,grid%olip,grid%cslp,grid%limp,grid%hc5p,grid%hc8p,grid%tolp,  &
              grid%xylp,grid%apip,grid%isop,grid%hc3p,grid%ethp,grid%o3p,grid%tco3,   &
              grid%mo2,grid%o1d,grid%olnn,grid%rpho,grid%xo2,                         &
              grid%ketp,grid%olnd,                                                    &
              ids,ide, jds,jde, kds,kde,                                              &
              ims,ime, jms,jme, kms,kme,                                              &
              its,ite,jts,jte,kts,kte        )
    END IF
 100 CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8ARRAY(chem, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                               (grid%em33-grid%sm33+1)*num_chem)
      CALL POPREAL8ARRAY(ebu, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1)*num_ebu)
      CALL A_EMISSIONS_DRIVER(grid%id,ktau,grid%dt,grid%DX, &
              adapt_step_flag, curr_secs, &
              grid%plumerisefire_frq,grid%stepfirepl, &
              grid%bioemdt,grid%stepbioe, &
              config_flags, &
              grid%gmt,ijulian,rri,a_rri,t_phy,moist,p8w,t8w,u_phy,v_phy,vvel, &
              grid%e_bio,p_phy,chem,a_chem,rho,a_rho,dz8w,a_dz8w, &
              grid%ne_area,emis_ant,emis_vol,grid%tsk, &
              grid%erod,g,emis_seas,emis_dust,tracer,a_tracer, &
              scaleant,a_scaleant,grid%scaleant_frq,grid%stepscaleant,grid%num_ant_steps, &
              scalebb,a_scalebb,grid%scalebb_frq,grid%stepscalebb,grid%num_bb_steps, &
              grid%check_count, grid%checkpoint_interval,                            &
              ebu , ebu_in,grid%mean_fct_agtf,grid%mean_fct_agef,grid%mean_fct_agsv, &
              grid%mean_fct_aggr,grid%firesize_agtf, &
              grid%firesize_agef,grid%firesize_agsv,grid%firesize_aggr, &
              grid%u10,grid%v10,grid%ivgtyp,grid%isltyp,grid%gsw,grid%vegfra,grid%rmol, &
              grid%ust,grid%znt,grid%dms_0,grid%erup_beg,grid%erup_end, &
              grid%xland,grid%xlat,grid%xlong, &
              z_at_w,zmid,grid%smois,dustin,seasin, &
              grid%sebio_iso,grid%sebio_oli,grid%sebio_api,grid%sebio_lim, &
              grid%sebio_xyl,grid%sebio_hc3,grid%sebio_ete,grid%sebio_olt, &
              grid%sebio_ket,grid%sebio_ald,grid%sebio_hcho,grid%sebio_eth, &
              grid%sebio_ora2,grid%sebio_co,grid%sebio_nr, &
              grid%sebio_sesq,grid%sebio_mbo, &
              grid%noag_grow,grid%noag_nongrow,grid%nononag,grid%slai, &
              grid%ebio_iso,grid%ebio_oli,grid%ebio_api,grid%ebio_lim,grid%ebio_xyl, &
              grid%ebio_hc3,grid%ebio_ete,grid%ebio_olt,grid%ebio_ket,grid%ebio_ald, &
              grid%ebio_hcho,grid%ebio_eth,grid%ebio_ora2,grid%ebio_co,grid%ebio_nr, &
              grid%ebio_no,grid%ebio_sesq,grid%ebio_mbo, &
              grid%ebio_c10h16,grid%ebio_tol,grid%ebio_bigalk, &
              grid%ebio_ch3oh,grid%ebio_acet,grid%ebio_nh3,grid%ebio_no2, &
              grid%ebio_c2h5oh,grid%ebio_ch3cooh,grid%ebio_mek,grid%ebio_bigene, &
              grid%ebio_c2h6,grid%ebio_c2h4,grid%ebio_c3h6,grid%ebio_c3h8,grid%ebio_so2, &
              grid%ebio_dms, &
              grid%ebio_alk3, grid%ebio_alk4, grid%ebio_alk5, grid%ebio_ole1, grid%ebio_ole2, &
              grid%ebio_aro1, grid%ebio_aro2, grid%ebio_ccho, grid%ebio_meoh, &
              grid%ebio_ethene, grid%ebio_hcooh, grid%ebio_terp, grid%ebio_bald, &
              grid%ebio_cco_oh, grid%ebio_rco_oh, &
              grid%clayfrac,grid%sandfrac,grid%dust_alpha,grid%dust_gamma,grid%dust_smtune,&
              grid%snowh,grid%zs, &
              grid%T2,grid%swdown, &
              grid%nmegan,grid%EFmegan, &
              grid%msebio_isop, &
              grid%mlai, &
              grid%pftp_bt, grid%pftp_nt, grid%pftp_sb, grid%pftp_hb, &
              grid%mtsa, &
              grid%mswdown, &
              grid%mebio_isop,grid%mebio_apin,grid%mebio_bpin, grid%mebio_bcar, &
              grid%mebio_acet,grid%mebio_mbo,grid%mebio_no, &
              current_month, &
             grid%ht, grid%refl_10cm, grid%ic_flashrate, grid%cg_flashrate, &
              emis_aircraft, &
              vprm_in,grid%rad_vprm,grid%lambda_vprm, &
              grid%alpha_vprm,grid%resp_vprm,grid%xtime, &
              grid%TSLB, wet_in,grid%RAINC,grid%RAINNC, &
              grid%potevp,grid%SFCEVP,grid%LU_INDEX, &
              grid%biomt_par,grid%emit_par,grid%ebio_co2oce, &
              eghg_bio, &
              ids,ide, jds,jde, kds,kde, &
              ims,ime, jms,jme, kms,kme, &
              its,ite,jts,jte,kts,kte)

    END IF
  END DO chem_tile_loop_ad
!$OMP END PARALLEL DO
  DO j=min9,jps,-1
    DO k=kpe,kps,-1
      CALL POPINTEGER4(ad_to1)
      DO i=ad_to1,ips,-1
        grid%a_z(i, k, j) = grid%a_z(i, k, j) + a_zmid(i, k&
&          , j)
        a_zmid(i, k, j) = 0.0_8
      END DO
    END DO
  END DO
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, its, ite, jts, jte )
   DO ij = 1 , grid%num_tiles
       its = grid%i_start(ij)
       ite = min(grid%i_end(ij),ide-1)
       jts = grid%j_start(ij)
       jte = min(grid%j_end(ij),jde-1)
       
       kts=k_start
       kte=min(k_end,kde-1)
    CALL POPREAL8ARRAY(grid%z, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL POPREAL8ARRAY(rh, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL POPREAL8ARRAY(z_at_w, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL POPREAL8ARRAY(t8w, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL POPREAL8ARRAY(p_phy, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL POPREAL8ARRAY(v_phy, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL POPREAL8ARRAY(u_phy, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL POPREAL8ARRAY(rho, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                            (grid%em33-grid%sm33+1))
    CALL POPREAL8ARRAY(p8w, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                            (grid%em33-grid%sm33+1))
    CALL POPREAL8ARRAY(t_phy, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                              (grid%em33-grid%sm33+1))
    CALL POPREAL8ARRAY(dz8w, (grid%em31-grid%sm31+1)*(grid%em32-grid%sm32+1)*&
                             (grid%em33-grid%sm33+1))

    CALL A_CHEM_PREP(config_flags, grid%u_2, grid%a_u_2, &
&               grid%v_2, grid%a_v_2, grid%p, &
&               grid%a_p, grid%pb, grid%alt, grid%a_alt&
&               , grid%ph_2, grid%a_ph_2, grid%phb, &
&               grid%t_2, grid%a_t_2, moist, a_moist, &
&               num_3d_m, rho, a_rho, p_phy, a_p_phy, u_phy, a_u_phy, &
&               v_phy, a_v_phy, p8w, a_p8w, t_phy, a_t_phy, t8w, a_t8w, grid%z, &
&               grid%a_z, z_at_w, a_z_at_w, dz8w, a_dz8w, rh, a_rh, grid%fnm, grid%fnp, &
&               ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, &
&               kme, its, ite, jts, jte, k_start, k_end)


  END DO 
!$OMP END PARALLEL DO

  DO j=min3,jps,-1
    CALL POPINTEGER4(ad_to0)
    DO k=ad_to0,kps,-1
      CALL POPINTEGER4(ad_to)
      DO i=ad_to,ips,-1
        grid%a_alt(i, k, j) = grid%a_alt(i, k, j) + a_rri(i&
&          , k, j)
        a_rri(i, k, j) = 0.0_8
      END DO
    END DO
  END DO
  CALL POPCONTROL2B(branch)
  IF (branch .NE. 0) THEN
    IF (branch .EQ. 1) THEN
      DO j=jpe,jps,-1
        DO k=kpe,kps,-1
          DO i=ipe,ips,-1
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) a_chem(i, k, j, p_nu0) = 0.0_8
          END DO
        END DO
      END DO
    ELSE
      DO j=jpe,jps,-1
        DO k=kpe,kps,-1
          DO i=ipe,ips,-1
            a_chem(i, k, j, p_ch4) = 0.0_8
          END DO
        END DO
      END DO
    END IF
  END IF
  DO nv=num_chem,1,-1
    DO j=jpe,jps,-1
      DO k=kpe,kps,-1
        DO i=ipe,ips,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) a_chem(i, k, j, nv) = 0.0_8
        END DO
      END DO
    END DO
  END DO
END SUBROUTINE chem_driver_ad
