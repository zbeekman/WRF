!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
MODULE g_module_gocart_aerosols
  USE module_model_constants, only: mwdry
  IMPLICIT NONE
  INTEGER, PARAMETER :: nbc1=1, noc1=2, nbc2=3, noc2=4

CONTAINS
!  Differentiation of gocart_aerosols_driver in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: chem
!   with respect to varying inputs: chem
  SUBROUTINE g_gocart_aerosols_driver(ktau, dt, config_flags, t_phy, &
&    moist, chem, g_chem, rho_phy, dz8w, p8w, dx, g, ids, ide, jds, jde, &
&    kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte&
&  )
    USE module_configure
    USE module_state_description
    IMPLICIT NONE
    TYPE(GRID_CONFIG_REC_TYPE), INTENT(IN) :: config_flags
    INTEGER, INTENT(IN) :: ktau, ids, ide, jds, jde, kds, kde, ims, ime&
&    , jms, jme, kms, kme, its, ite, jts, jte, kts, kte
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_moist), INTENT(IN) ::&
&    moist
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem), INTENT(INOUT) &
&    :: chem
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem), INTENT(INOUT) &
&    :: g_chem
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: t_phy, &
&    dz8w, p8w, rho_phy
    REAL, INTENT(IN) :: dt, dx, g
    INTEGER :: ndt1, nmx, i, j, k, imx, jmx, lmx
    REAL*8, DIMENSION(1, 1, 1) :: tmp, airden, airmas
    REAL*8 :: chmlos(1, 1, 1, 4)
    REAL*8 :: bchmlos(1, 1, 4)
    REAL*8 :: pc2(1, 1, 1, 2)
    REAL*8 :: g_pc2(1, 1, 1, 2)
    REAL*8 :: tc(4), tt1, tt2
    REAL*8 :: g_tc(4), g_tt1, g_tt2
    REAL, PARAMETER :: mw_c=12.
    imx = 1
    jmx = 1
    lmx = 1
    nmx = 4
    ndt1 = IFIX(dt)
    g_pc2 = 0.0_8
    g_tc = 0.0_8
    DO j=jts,jte
      DO k=kts,kte-1
        DO i=its,ite
          airmas(1, 1, 1) = -((p8w(i, k+1, j)-p8w(i, k, j))*dx*dx/g)
          g_pc2(1, 1, 1, 1) = 0.0_8
          pc2(1, 1, 1, 1) = 0.
          g_pc2(1, 1, 1, 2) = 0.0_8
          pc2(1, 1, 1, 2) = 0.
          g_tc(1) = mwdry*1.d-9*g_chem(i, k, j, p_bc1)/mw_c
          tc(1) = chem(i, k, j, p_bc1)/mw_c*mwdry*1.d-9
          g_tc(2) = mwdry*1.d-9*g_chem(i, k, j, p_oc1)/mw_c
          tc(2) = chem(i, k, j, p_oc1)/mw_c*mwdry*1.d-9
          g_tc(3) = mwdry*1.d-9*g_chem(i, k, j, p_bc2)/mw_c
          tc(3) = chem(i, k, j, p_bc2)/mw_c*mwdry*1.d-9
          g_tc(4) = mwdry*1.d-9*g_chem(i, k, j, p_oc2)/mw_c
          tc(4) = chem(i, k, j, p_oc2)/mw_c*mwdry*1.d-9
          g_tt1 = g_tc(3)
          tt1 = tc(3)
          CALL G_CHEM_1(imx, jmx, lmx, nmx, ndt1, airmas, tc, g_tc, &
&                  chmlos, bchmlos, pc2, g_pc2)
          CALL G_CHEM_2(imx, jmx, lmx, nmx, ndt1, airmas, tc, g_tc, pc2&
&                  , g_pc2)
          g_tt2 = g_tc(3) - g_tt1
          tt2 = tc(3) - tt1
          g_chem(i, k, j, p_bc1) = mw_c*1.e9*g_tc(1)/mwdry
          chem(i, k, j, p_bc1) = tc(1)/mwdry*mw_c*1.e9
          g_chem(i, k, j, p_oc1) = mw_c*1.e9*g_tc(2)/mwdry
          chem(i, k, j, p_oc1) = tc(2)/mwdry*mw_c*1.e9
          g_chem(i, k, j, p_bc2) = mw_c*1.e9*g_tc(3)/mwdry
          chem(i, k, j, p_bc2) = tc(3)/mwdry*mw_c*1.e9
          g_chem(i, k, j, p_oc2) = mw_c*1.e9*(g_tc(4)+8.*g_tt2)/mwdry
          chem(i, k, j, p_oc2) = (tc(4)+8.*tt2)/mwdry*mw_c*1.e9
        END DO
      END DO
    END DO
  END SUBROUTINE g_gocart_aerosols_driver

!  Differentiation of sum_pm_gocart in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: pm10 pm2_5_dry_ec pm2_5_dry
!   with respect to varying inputs: pm10 pm2_5_dry_ec alt chem
!                pm2_5_dry
  SUBROUTINE g_sum_pm_gocart(alt, g_alt, chem, g_chem, pm2_5_dry, &
&    g_pm2_5_dry, pm2_5_dry_ec, g_pm2_5_dry_ec, pm10, g_pm10, ids, ide, &
&    jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte&
&    , kts, kte)
    USE module_configure
    USE module_state_description
    USE module_data_gocartchem, only: nh4_mfac,oc_mfac
    IMPLICIT NONE
    REAL, PARAMETER :: mwso4=96.0576
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    pm2_5_dry, pm2_5_dry_ec, pm10
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    g_pm2_5_dry, g_pm2_5_dry_ec, g_pm10
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: alt
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_alt
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem), INTENT(IN) :: &
&    chem
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem), INTENT(IN) :: &
&    g_chem
    REAL :: d_2_5, s_2_5, d_10, sulfate
    REAL :: g_sulfate
    INTEGER :: i, j, k, ii, jj, n
    d_2_5 = 0.286
    s_2_5 = 0.942
    d_10 = 0.87
    g_pm2_5_dry(its:ite, kts:kte, jts:jte) = 0.0_8
    pm2_5_dry(its:ite, kts:kte, jts:jte) = 0.
    g_pm10(its:ite, kts:kte, jts:jte) = 0.0_8
    pm10(its:ite, kts:kte, jts:jte) = 0.
    g_pm2_5_dry_ec(its:ite, kts:kte, jts:jte) = 0.0_8
    pm2_5_dry_ec(its:ite, kts:kte, jts:jte) = 0.
    DO j=jts,jte
      IF (jde - 1 .GT. j) THEN
        jj = j
      ELSE
        jj = jde - 1
      END IF
      DO k=kts,kte
        DO i=its,ite
          IF (ide - 1 .GT. i) THEN
            ii = i
          ELSE
            ii = ide - 1
          END IF
          g_sulfate = 1.e3*mwso4*g_chem(ii, k, jj, p_sulf)/mwdry
          sulfate = chem(ii, k, jj, p_sulf)*mwso4/mwdry*1.e3
          DO n=p_p25,p_dust_1
            g_pm2_5_dry(i, k, j) = g_pm2_5_dry(i, k, j) + g_chem(ii, k, &
&              jj, n)
            pm2_5_dry(i, k, j) = pm2_5_dry(i, k, j) + chem(ii, k, jj, n)
          END DO
          g_pm2_5_dry(i, k, j) = g_pm2_5_dry(i, k, j) + d_2_5*g_chem(ii&
&            , k, jj, p_dust_2) + g_chem(ii, k, jj, p_seas_1) + s_2_5*&
&            g_chem(ii, k, jj, p_seas_2) + nh4_mfac*g_sulfate + (oc_mfac-&
&            1.)*(g_chem(ii, k, jj, p_oc1)+g_chem(ii, k, jj, p_oc2))
          pm2_5_dry(i, k, j) = pm2_5_dry(i, k, j) + chem(ii, k, jj, &
&            p_dust_2)*d_2_5 + chem(ii, k, jj, p_seas_1) + chem(ii, k, jj&
&            , p_seas_2)*s_2_5 + sulfate*nh4_mfac + (chem(ii, k, jj, &
&            p_oc1)+chem(ii, k, jj, p_oc2))*(oc_mfac-1.)
          g_pm2_5_dry(i, k, j) = (g_pm2_5_dry(i, k, j)*alt(ii, k, jj)-&
&            pm2_5_dry(i, k, j)*g_alt(ii, k, jj))/alt(ii, k, jj)**2
          pm2_5_dry(i, k, j) = pm2_5_dry(i, k, j)/alt(ii, k, jj)
        END DO
      END DO
    END DO
    DO j=jts,jte
      IF (jde - 1 .GT. j) THEN
        jj = j
      ELSE
        jj = jde - 1
      END IF
      DO k=kts,kte
        DO i=its,ite
          IF (ide - 1 .GT. i) THEN
            ii = i
          ELSE
            ii = ide - 1
          END IF
          g_sulfate = 1.e3*mwso4*g_chem(ii, k, jj, p_sulf)/mwdry
          sulfate = chem(ii, k, jj, p_sulf)*mwso4/mwdry*1.e3
          DO n=p_p25,p_dust_3
            g_pm10(i, k, j) = g_pm10(i, k, j) + g_chem(ii, k, jj, n)
            pm10(i, k, j) = pm10(i, k, j) + chem(ii, k, jj, n)
          END DO
          DO n=p_seas_1,p_seas_3
            g_pm10(i, k, j) = g_pm10(i, k, j) + g_chem(ii, k, jj, n)
            pm10(i, k, j) = pm10(i, k, j) + chem(ii, k, jj, n)
          END DO
          g_pm10(i, k, j) = g_pm10(i, k, j) + nh4_mfac*g_sulfate + d_10*&
&            g_chem(ii, k, jj, p_dust_4) + g_chem(ii, k, jj, p_p10) + (&
&            oc_mfac-1.)*(g_chem(ii, k, jj, p_oc1)+g_chem(ii, k, jj, &
&            p_oc2))
          pm10(i, k, j) = pm10(i, k, j) + sulfate*nh4_mfac + chem(ii, k&
&            , jj, p_dust_4)*d_10 + chem(ii, k, jj, p_p10) + (chem(ii, k&
&            , jj, p_oc1)+chem(ii, k, jj, p_oc2))*(oc_mfac-1.)
          g_pm10(i, k, j) = (g_pm10(i, k, j)*alt(ii, k, jj)-pm10(i, k, j&
&            )*g_alt(ii, k, jj))/alt(ii, k, jj)**2
          pm10(i, k, j) = pm10(i, k, j)/alt(ii, k, jj)
        END DO
      END DO
    END DO
  END SUBROUTINE g_sum_pm_gocart

!  Differentiation of chem_1 in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: pc2 tc
!   with respect to varying inputs: pc2 tc
  SUBROUTINE G_CHEM_1(imx, jmx, lmx, nmx, ndt1, airm, tc, g_tc, chmlos, &
&    bchmlos, pc2, g_pc2)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: lmx, nmx, imx, jmx, ndt1
    REAL*8, INTENT(IN) :: airm(imx, jmx, lmx)
    REAL*8, INTENT(INOUT) :: tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: g_tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: chmlos(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: bchmlos(imx, jmx, nmx)
    REAL*8, INTENT(OUT) :: pc2(imx, jmx, lmx, 2)
    REAL*8, INTENT(OUT) :: g_pc2(imx, jmx, lmx, 2)
    REAL*8 :: r1, c0, r2, rkt, c1
    REAL*8 :: g_c0, g_c1
    INTEGER :: np, n, i, j, l
    r1 = 4.63d-6
    DO n=1,nmx
      IF (n .EQ. nbc1 .OR. n .EQ. noc1) THEN
        IF (n .EQ. nbc1) np = 1
        IF (n .EQ. noc1) np = 2
        DO l=1,lmx
          DO j=1,jmx
            DO i=1,imx
              g_c0 = g_tc(i, j, l, n)
              c0 = tc(i, j, l, n)
              r2 = 0.0
              rkt = (r1+r2)*REAL(ndt1)
              g_c1 = EXP(-rkt)*g_c0
              c1 = c0*EXP(-rkt)
              IF (c1 .LT. 1.0d-32) THEN
                c1 = 1.0d-32
                g_c1 = 0.0_8
              ELSE
                c1 = c1
              END IF
              g_tc(i, j, l, n) = g_c1
              tc(i, j, l, n) = c1
              g_pc2(i, j, l, np) = r1*(g_c0-g_c1)/(r1+r2)
              pc2(i, j, l, np) = (c0-c1)*r1/(r1+r2)
              chmlos(i, j, l, n) = chmlos(i, j, l, n) + pc2(i, j, l, np)&
&                *airm(i, j, l)
            END DO
          END DO
        END DO
        DO j=1,jmx
          DO i=1,imx
            bchmlos(i, j, n) = bchmlos(i, j, n) + SUM(chmlos(i, j, :, n)&
&              )
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE G_CHEM_1

!  Differentiation of chem_2 in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: tc
!   with respect to varying inputs: pc2 tc
  SUBROUTINE G_CHEM_2(imx, jmx, lmx, nmx, ndt1, airm, tc, g_tc, pc2, &
&    g_pc2)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: lmx, imx, jmx, nmx, ndt1
    REAL*8, INTENT(IN) :: airm(imx, jmx, lmx)
    REAL*8, INTENT(INOUT) :: tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: g_tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(IN) :: pc2(imx, jmx, lmx, 2)
    REAL*8, INTENT(IN) :: g_pc2(imx, jmx, lmx, 2)
    INTEGER :: np, n, i, j, l
    REAL*8 :: c0, pp, rkt, c1
    REAL*8 :: g_c0, g_pp, g_c1
    DO n=1,nmx
      IF (n .EQ. nbc2 .OR. n .EQ. noc2) THEN
        IF (n .EQ. nbc2) np = 1
        IF (n .EQ. noc2) np = 2
        DO l=1,lmx
          DO j=1,jmx
            DO i=1,imx
              g_c0 = g_tc(i, j, l, n)
              c0 = tc(i, j, l, n)
              g_pp = g_pc2(i, j, l, np)
              pp = pc2(i, j, l, np)
              g_c1 = g_c0 + g_pp
              c1 = c0 + pp
              IF (c1 .LT. 1.0d-32) THEN
                c1 = 1.0d-32
                g_c1 = 0.0_8
              ELSE
                c1 = c1
              END IF
              g_tc(i, j, l, n) = g_c1
              tc(i, j, l, n) = c1
            END DO
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE G_CHEM_2

END MODULE g_module_gocart_aerosols
