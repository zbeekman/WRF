!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
MODULE g_module_gocart_chem
  IMPLICIT NONE

CONTAINS
!  Differentiation of gocart_chem_driver in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: chem
!   with respect to varying inputs: t_phy rho_phy chem
  SUBROUTINE g_gocart_chem_driver(curr_secs, dt, config_flags, gmt, &
&    julday, t_phy, g_t_phy, moist, chem, g_chem, rho_phy, g_rho_phy, &
&    dz8w, p8w, backg_oh, backg_h2o2, backg_no3, gd_cldf, dx, g, xlat, &
&    xlong, ttday, tcosz, ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte)
    USE module_configure
    USE module_state_description
    USE module_gocart_chem, only: szangle
    IMPLICIT NONE
    TYPE(GRID_CONFIG_REC_TYPE), INTENT(IN) :: config_flags
    INTEGER, INTENT(IN) :: julday, ids, ide, jds, jde, kds, kde, ims, &
&    ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_moist), INTENT(IN) ::&
&    moist
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem), INTENT(INOUT) &
&    :: chem
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem), INTENT(INOUT) &
&    :: g_chem
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: xlat, xlong, ttday&
&    , tcosz
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(IN) :: &
&    gd_cldf
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: t_phy, &
&    backg_oh, backg_h2o2, backg_no3, dz8w, p8w, rho_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_t_phy, &
&    g_rho_phy
    REAL(kind=8), INTENT(IN) :: curr_secs
    REAL, INTENT(IN) :: dt, dx, g, gmt
    INTEGER :: nmx, i, j, k, imx, jmx, lmx
    REAL*8, DIMENSION(1, 1, 1) :: tmp, airden, airmas, oh, xno3, h2o2, &
&    chldms_oh, chldms_no3, chldms_x, chpso2, chpmsa, chpso4, chlso2_oh, &
&    chlso2_aq, cldf
    REAL*8, DIMENSION(1, 1, 1) :: g_tmp, g_airden, g_oh, g_xno3, g_h2o2&
&    , g_cldf
    REAL*8, DIMENSION(1, 1, 4) :: tdry
    REAL*8, DIMENSION(1, 1) :: cossza
    REAL*8, DIMENSION(1, 1) :: g_cossza
    REAL, DIMENSION(1, 1) :: sza, cosszax
    REAL*8, DIMENSION(1, 1, 1, 4) :: tc, bems
    REAL*8, DIMENSION(1, 1, 1, 4) :: g_tc
    REAL*8, DIMENSION(1) :: dxy
    REAL(kind=8) :: xtime, xhour
    REAL :: rlat, xlonn
    REAL :: zenith, zenita, azimuth, xmin, xtimin, gmtp
    INTEGER(kind=8) :: ixhour
    REAL*8 :: result1
    imx = 1
    jmx = 1
    lmx = 1
    nmx = 4
    tdry = 0.d0
    xtime = curr_secs/60._8
    ixhour = INT(gmt + .01, 8) + INT(xtime/60._8, 8)
    xhour = REAL(ixhour, 8)
    result1 = REAL(xtime - xhour*60._8, 8)
    xmin = 60.*gmt + result1
    gmtp = MOD(xhour, 24._8)
    gmtp = gmtp + xmin/60.
    dxy(1) = dx*dx
    SELECT CASE  (config_flags%chem_opt) 
    CASE (GOCART_SIMPLE) 
      CALL WRF_DEBUG(15, 'calling gocart chemistry ')
      g_h2o2 = 0.0_8
      g_tmp = 0.0_8
      g_airden = 0.0_8
      g_tc = 0.0_8
      DO j=jts,jte
        DO i=its,ite
          zenith = 0.
          zenita = 0.
          azimuth = 0.
          rlat = xlat(i, j)*3.1415926535590/180.
          xlonn = xlong(i, j)
          CALL SZANGLE(1, 1, julday, gmtp, sza, cosszax, xlonn, rlat)
          g_cossza(1, 1) = 0.0_8
          cossza(1, 1) = cosszax(1, 1)
          DO k=kts,kte-1
            chldms_oh = 0.
            chldms_no3 = 0.
            chldms_x = 0.
            chpso2 = 0.
            chpmsa = 0.
            chpso4 = 0.
            chlso2_oh = 0.
            chlso2_aq = 0.
            IF (PRESENT(gd_cldf)) THEN
              g_cldf(1, 1, 1) = 0.0_8
              cldf(1, 1, 1) = gd_cldf(i, k, j)
            ELSE
              g_cldf(1, 1, 1) = 0.0_8
              cldf(1, 1, 1) = 0.
            END IF
            IF (p_qc .GT. 1 .AND. p_qi .GT. 1) THEN
              IF (moist(i, k, j, p_qc) .GT. 0 .OR. moist(i, k, j, p_qi) &
&                  .GT. 0.) THEN
                g_cldf(1, 1, 1) = 0.0_8
                cldf(1, 1, 1) = 1.
              END IF
            ELSE IF (p_qc .GT. 1 .AND. p_qi .LE. 1) THEN
              IF (moist(i, k, j, p_qc) .GT. 0.) THEN
                g_cldf(1, 1, 1) = 0.0_8
                cldf(1, 1, 1) = 1.
              END IF
            END IF
            g_tc(1, 1, 1, 1) = 1.d-6*g_chem(i, k, j, p_dms)
            tc(1, 1, 1, 1) = chem(i, k, j, p_dms)*1.d-6
            g_tc(1, 1, 1, 2) = 1.d-6*g_chem(i, k, j, p_so2)
            tc(1, 1, 1, 2) = chem(i, k, j, p_so2)*1.d-6
            g_tc(1, 1, 1, 3) = 1.d-6*g_chem(i, k, j, p_sulf)
            tc(1, 1, 1, 3) = chem(i, k, j, p_sulf)*1.d-6
            g_tc(1, 1, 1, 4) = 1.d-6*g_chem(i, k, j, p_msa)
            tc(1, 1, 1, 4) = chem(i, k, j, p_msa)*1.d-6
            airmas(1, 1, 1) = -((p8w(i, k+1, j)-p8w(i, k, j))*dx*dx/g)
            g_airden(1, 1, 1) = g_rho_phy(i, k, j)
            airden(1, 1, 1) = rho_phy(i, k, j)
            g_tmp(1, 1, 1) = g_t_phy(i, k, j)
            tmp(1, 1, 1) = t_phy(i, k, j)
            g_oh(1, 1, 1) = 0.0_8
            oh(1, 1, 1) = 86400./dt*cossza(1, 1)*backg_oh(i, k, j)/tcosz&
&              (i, j)
            g_h2o2(1, 1, 1) = 0.0_8
            h2o2(1, 1, 1) = backg_h2o2(i, k, j)
            IF (cossza(1, 1) .GT. 0.0) THEN
              g_xno3(1, 1, 1) = 0.0_8
              xno3(1, 1, 1) = 0.0
            ELSE
              g_xno3(1, 1, 1) = 0.0_8
              xno3(1, 1, 1) = backg_no3(i, k, j)/(1.0-ttday(i, j)/86400.&
&                )
            END IF
            g_xno3 = 0.0_8
            g_oh = 0.0_8
            CALL G_CHMDRV_SU(imx, jmx, lmx, nmx, dt, tmp, g_tmp, airden&
&                       , g_airden, airmas, oh, g_oh, xno3, g_xno3, h2o2&
&                       , g_h2o2, cldf, tc, g_tc, tdry, cossza, chldms_oh&
&                       , chldms_no3, chldms_x, chpso2, chpmsa, chpso4, &
&                       chlso2_oh, chlso2_aq)
            g_chem(i, k, j, p_dms) = 1.e6*g_tc(1, 1, 1, 1)
            chem(i, k, j, p_dms) = tc(1, 1, 1, 1)*1.e6
            g_chem(i, k, j, p_so2) = 1.e6*g_tc(1, 1, 1, 2)
            chem(i, k, j, p_so2) = tc(1, 1, 1, 2)*1.e6
            g_chem(i, k, j, p_sulf) = 1.e6*g_tc(1, 1, 1, 3)
            chem(i, k, j, p_sulf) = tc(1, 1, 1, 3)*1.e6
            g_chem(i, k, j, p_msa) = 1.e6*g_tc(1, 1, 1, 4)
            chem(i, k, j, p_msa) = tc(1, 1, 1, 4)*1.e6
          END DO
        END DO
      END DO
    CASE (GOCARTRACM_KPP, GOCARTRADM2_KPP, GOCARTRADM2) 
      CALL WRF_DEBUG(15, &
&               'calling gocart chemistry in addition to racm_kpp')
      g_h2o2 = 0.0_8
      g_xno3 = 0.0_8
      g_oh = 0.0_8
      g_tmp = 0.0_8
      g_airden = 0.0_8
      g_tc = 0.0_8
      DO j=jts,jte
        DO i=its,ite
          zenith = 0.
          zenita = 0.
          azimuth = 0.
          rlat = xlat(i, j)*3.1415926535590/180.
          xlonn = xlong(i, j)
          CALL SZANGLE(1, 1, julday, gmtp, sza, cosszax, xlonn, rlat)
          cossza(1, 1) = cosszax(1, 1)
          DO k=kts,kte-1
            chldms_oh = 0.
            chldms_no3 = 0.
            chldms_x = 0.
            chpso2 = 0.
            chpmsa = 0.
            chpso4 = 0.
            chlso2_oh = 0.
            chlso2_aq = 0.
            IF (PRESENT(gd_cldf)) THEN
              g_cldf(1, 1, 1) = 0.0_8
              cldf(1, 1, 1) = gd_cldf(i, k, j)
            ELSE
              g_cldf(1, 1, 1) = 0.0_8
              cldf(1, 1, 1) = 0.
            END IF
            IF (p_qi .GT. 1) THEN
              IF (moist(i, k, j, p_qc) .GT. 0 .OR. moist(i, k, j, p_qi) &
&                  .GT. 0.) THEN
                g_cldf(1, 1, 1) = 0.0_8
                cldf(1, 1, 1) = 1.
              END IF
            ELSE IF (p_qc .GT. 1) THEN
              IF (moist(i, k, j, p_qc) .GT. 0.) THEN
                g_cldf(1, 1, 1) = 0.0_8
                cldf(1, 1, 1) = 1.
              END IF
            END IF
            g_tc(1, 1, 1, 1) = 1.d-6*g_chem(i, k, j, p_dms)
            tc(1, 1, 1, 1) = chem(i, k, j, p_dms)*1.d-6
            g_tc(1, 1, 1, 2) = 1.d-6*g_chem(i, k, j, p_so2)
            tc(1, 1, 1, 2) = chem(i, k, j, p_so2)*1.d-6
            g_tc(1, 1, 1, 3) = 1.d-6*g_chem(i, k, j, p_sulf)
            tc(1, 1, 1, 3) = chem(i, k, j, p_sulf)*1.d-6
            g_tc(1, 1, 1, 4) = 1.d-6*g_chem(i, k, j, p_msa)
            tc(1, 1, 1, 4) = chem(i, k, j, p_msa)*1.d-6
            airmas(1, 1, 1) = -((p8w(i, k+1, j)-p8w(i, k, j))*dx*dx/g)
            g_airden(1, 1, 1) = g_rho_phy(i, k, j)
            airden(1, 1, 1) = rho_phy(i, k, j)
            g_tmp(1, 1, 1) = g_t_phy(i, k, j)
            tmp(1, 1, 1) = t_phy(i, k, j)
            g_oh(1, 1, 1) = 1.d-6*g_chem(i, k, j, p_ho)
            oh(1, 1, 1) = chem(i, k, j, p_ho)*1.d-6
            g_h2o2(1, 1, 1) = 1.d-6*g_chem(i, k, j, p_h2o2)
            h2o2(1, 1, 1) = chem(i, k, j, p_h2o2)*1.d-6
            g_xno3(1, 1, 1) = 1.d-6*g_chem(i, k, j, p_no3)
            xno3(1, 1, 1) = chem(i, k, j, p_no3)*1.d-6
            IF (cossza(1, 1) .GT. 0.0) THEN
              g_xno3(1, 1, 1) = 0.0_8
              xno3(1, 1, 1) = 0.
            END IF
            CALL G_CHMDRV_SU(imx, jmx, lmx, nmx, dt, tmp, g_tmp, airden&
&                       , g_airden, airmas, oh, g_oh, xno3, g_xno3, h2o2&
&                       , g_h2o2, cldf, tc, g_tc, tdry, cossza, chldms_oh&
&                       , chldms_no3, chldms_x, chpso2, chpmsa, chpso4, &
&                       chlso2_oh, chlso2_aq)
            g_chem(i, k, j, p_dms) = 1.e6*g_tc(1, 1, 1, 1)
            chem(i, k, j, p_dms) = tc(1, 1, 1, 1)*1.e6
            g_chem(i, k, j, p_so2) = 1.e6*g_tc(1, 1, 1, 2)
            chem(i, k, j, p_so2) = tc(1, 1, 1, 2)*1.e6
            g_chem(i, k, j, p_sulf) = 1.e6*g_tc(1, 1, 1, 3)
            chem(i, k, j, p_sulf) = tc(1, 1, 1, 3)*1.e6
            g_chem(i, k, j, p_msa) = 1.e6*g_tc(1, 1, 1, 4)
            chem(i, k, j, p_msa) = tc(1, 1, 1, 4)*1.e6
            g_chem(i, k, j, p_h2o2) = 1.e6*g_h2o2(1, 1, 1)
            chem(i, k, j, p_h2o2) = h2o2(1, 1, 1)*1.e6
          END DO
        END DO
      END DO
    END SELECT
  END SUBROUTINE g_gocart_chem_driver

!  Differentiation of chmdrv_su in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: h2o2 tc
!   with respect to varying inputs: h2o2 xno3 oh tmp airden tc
  SUBROUTINE G_CHMDRV_SU(imx, jmx, lmx, nmx, dt1, tmp, g_tmp, airden, &
&    g_airden, airmas, oh, g_oh, xno3, g_xno3, h2o2, g_h2o2, cldf, tc, &
&    g_tc, tdry, cossza, chldms_oh, chldms_no3, chldms_x, chpso2, chpmsa&
&    , chpso4, chlso2_oh, chlso2_aq)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nmx, imx, jmx, lmx
    INTEGER :: ndt1
    REAL, INTENT(IN) :: dt1
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: tmp, airden, airmas
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: g_tmp, g_airden
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: oh, xno3, cldf
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: g_oh, g_xno3
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(INOUT) :: h2o2
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(INOUT) :: g_h2o2
    REAL*8, INTENT(INOUT) :: tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: g_tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: tdry(imx, jmx, nmx)
    REAL*8, DIMENSION(imx, jmx), INTENT(IN) :: cossza
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(INOUT) :: chldms_oh, &
&    chldms_no3
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(INOUT) :: chldms_x, chpso2&
&    , chpmsa
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(INOUT) :: chpso4, chlso2_oh&
&    , chlso2_aq
    REAL*8, DIMENSION(imx, jmx, lmx) :: pso2_dms, pmsa_dms, pso4_so2
    REAL*8, DIMENSION(imx, jmx, lmx) :: g_pso2_dms, g_pmsa_dms, &
&    g_pso4_so2
    ndt1 = IFIX(dt1)
    IF (ndt1 .LE. 0) THEN
      STOP
    ELSE
      CALL G_CHEM_DMS(imx, jmx, lmx, nmx, ndt1, tmp, g_tmp, airden, &
&                g_airden, airmas, oh, g_oh, xno3, g_xno3, tc, g_tc, &
&                chldms_oh, chldms_no3, chldms_x, chpso2, chpmsa, cossza&
&                , pso2_dms, g_pso2_dms, pmsa_dms, g_pmsa_dms)
      CALL G_CHEM_SO2(imx, jmx, lmx, nmx, ndt1, tmp, g_tmp, airden, &
&                g_airden, airmas, cldf, oh, g_oh, h2o2, g_h2o2, tc, g_tc&
&                , tdry, cossza, chpso4, chlso2_oh, chlso2_aq, pso2_dms, &
&                g_pso2_dms, pso4_so2, g_pso4_so2)
      CALL G_CHEM_SO4(imx, jmx, lmx, nmx, ndt1, airmas, tc, g_tc, tdry, &
&                cossza, pso4_so2, g_pso4_so2)
      CALL G_CHEM_MSA(imx, jmx, lmx, nmx, ndt1, airmas, tc, g_tc, tdry, &
&                cossza, pmsa_dms, g_pmsa_dms)
    END IF
  END SUBROUTINE G_CHMDRV_SU

!  Differentiation of chem_dms in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: pso2_dms pmsa_dms tc
!   with respect to varying inputs: xno3 oh tmp airden tc
  SUBROUTINE G_CHEM_DMS(imx, jmx, lmx, nmx, ndt1, tmp, g_tmp, airden, &
&    g_airden, airmas, oh, g_oh, xno3, g_xno3, tc, g_tc, chldms_oh, &
&    chldms_no3, chldms_x, chpso2, chpmsa, cossza, pso2_dms, g_pso2_dms, &
&    pmsa_dms, g_pmsa_dms)
  USE module_data_gocartchem
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nmx, ndt1, imx, jmx, lmx
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: tmp, airden, airmas
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: g_tmp, g_airden
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: oh, xno3
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: g_oh, g_xno3
    REAL*8, INTENT(INOUT) :: tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: g_tc(imx, jmx, lmx, nmx)
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(INOUT) :: chldms_oh, &
&    chldms_no3
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(INOUT) :: chldms_x, chpso2&
&    , chpmsa
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(OUT) :: pso2_dms, pmsa_dms
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(OUT) :: g_pso2_dms, &
&    g_pmsa_dms
    REAL*8, DIMENSION(imx, jmx), INTENT(IN) :: cossza
    REAL*8, PARAMETER :: fx=1.0
    REAL*8, PARAMETER :: a=0.75
    REAL*8, PARAMETER :: b=0.25
    REAL*8, PARAMETER :: eff=1.0
    REAL*8, PARAMETER :: f=1000.0/airmw*6.022d23*1.0d-6
    INTEGER :: i, j, l
    REAL(kind=8) :: tk, o2, dms0, rk1, rk2, rk3, dms_oh, dms, xoh, xn3, &
&    xx
    REAL(kind=8) :: g_tk, g_o2, g_dms0, g_rk1, g_rk2, g_rk3, g_dms_oh, &
&    g_dms
    REAL(kind=8) :: arg1
    REAL(kind=8) :: g_arg1
    REAL*8 :: g_y1
    REAL*8 :: y1
    g_pso2_dms = 0.0_8
    g_pmsa_dms = 0.0_8
    DO l=1,lmx
      DO j=1,jmx
        DO i=1,imx
          g_tk = g_tmp(i, j, l)
          tk = tmp(i, j, l)
          g_o2 = f*0.21*g_airden(i, j, l)
          o2 = airden(i, j, l)*f*0.21
          g_dms0 = g_tc(i, j, l, ndms)
          dms0 = tc(i, j, l, ndms)
          rk1 = 0.0d0
          rk2 = 0.0d0
          rk3 = 0.0d0
          IF (oh(i, j, l) .GT. 0.0) THEN
            g_rk1 = f*((1.7d-42*(EXP(7810.0/tk)*g_o2-7810.0*g_tk*EXP(&
&              7810.0/tk)*o2/tk**2)*(1.0+5.5d-31*EXP(7460.0/tk)*o2)-&
&              1.7d-42*EXP(7810.0/tk)*o2*5.5d-31*(EXP(7460.0/tk)*g_o2-&
&              7460.0*g_tk*EXP(7460.0/tk)*o2/tk**2))*oh(i, j, l)*airden(i&
&              , j, l)/(1.0+5.5d-31*EXP(7460.0/tk)*o2)**2+1.7d-42*EXP(&
&              7810.0/tk)*o2*(g_oh(i, j, l)*airden(i, j, l)+oh(i, j, l)*&
&              g_airden(i, j, l))/(1.0+5.5d-31*EXP(7460.0/tk)*o2))
            rk1 = 1.7d-42*EXP(7810.0/tk)*o2/(1.0+5.5d-31*EXP(7460.0/tk)*&
&              o2)*oh(i, j, l)*airden(i, j, l)*f
            g_rk2 = 1.2d-11*f*(260.0*g_tk*EXP(-(260.0/tk))*oh(i, j, l)*&
&              airden(i, j, l)/tk**2+EXP(-(260.0/tk))*(g_oh(i, j, l)*&
&              airden(i, j, l)+oh(i, j, l)*g_airden(i, j, l)))
            rk2 = 1.2d-11*EXP(-(260.0/tk))*oh(i, j, l)*airden(i, j, l)*f
          ELSE
            g_rk1 = 0.0_8
            g_rk2 = 0.0_8
          END IF
          IF (cossza(i, j) .LE. 0.0) THEN
            g_rk3 = 1.9d-13*f*(EXP(500.0/tk)*(g_xno3(i, j, l)*airden(i, &
&              j, l)+xno3(i, j, l)*g_airden(i, j, l))-500.0*g_tk*EXP(&
&              500.0/tk)*xno3(i, j, l)*airden(i, j, l)/tk**2)
            rk3 = 1.9d-13*EXP(500.0/tk)*xno3(i, j, l)*airden(i, j, l)*f
          ELSE
            g_rk3 = 0.0_8
          END IF
          g_arg1 = -(fx*REAL(ndt1)*(g_rk1+g_rk2))
          arg1 = -((rk1+rk2)*fx*REAL(ndt1))
          g_dms_oh = g_dms0*EXP(arg1) + dms0*g_arg1*EXP(arg1)
          dms_oh = dms0*EXP(arg1)
          g_arg1 = -(fx*REAL(ndt1)*g_rk3)
          arg1 = -(rk3*fx*REAL(ndt1))
          g_dms = g_dms_oh*EXP(arg1) + dms_oh*g_arg1*EXP(arg1)
          dms = dms_oh*EXP(arg1)
          IF (dms .LT. 1.0d-32) THEN
            dms = 1.0d-32
            g_dms = 0.0_8
          ELSE
            dms = dms
          END IF
          g_tc(i, j, l, ndms) = g_dms
          tc(i, j, l, ndms) = dms
          IF (rk1 + rk2 .EQ. 0.0) THEN
            g_pmsa_dms(i, j, l) = 0.0_8
            pmsa_dms(i, j, l) = 0.0d0
          ELSE
            g_y1 = eff*(b*((g_dms0-g_dms_oh)*rk1+(dms0-dms_oh)*g_rk1)*(&
&              rk1+rk2)*fx-(dms0-dms_oh)*b*rk1*fx*(g_rk1+g_rk2))/((rk1+&
&              rk2)**2*fx**2)
            y1 = (dms0-dms_oh)*b*rk1/((rk1+rk2)*fx)*eff
            IF (0.0d0 .LT. y1) THEN
              g_pmsa_dms(i, j, l) = g_y1
              pmsa_dms(i, j, l) = y1
            ELSE
              g_pmsa_dms(i, j, l) = 0.0_8
              pmsa_dms(i, j, l) = 0.0d0
            END IF
          END IF
          IF (0.0d0 .LT. dms0 - dms - pmsa_dms(i, j, l)) THEN
            g_pso2_dms(i, j, l) = g_dms0 - g_dms - g_pmsa_dms(i, j, l)
            pso2_dms(i, j, l) = dms0 - dms - pmsa_dms(i, j, l)
          ELSE
            g_pso2_dms(i, j, l) = 0.0_8
            pso2_dms(i, j, l) = 0.0d0
          END IF
          xoh = (dms0-dms_oh)/fx*airmas(i, j, l)/airmw*smw
          xn3 = (dms_oh-dms)/fx*airmas(i, j, l)/airmw*smw
          xx = (dms0-dms)*airmas(i, j, l)/airmw*smw - xoh - xn3
          chldms_oh(i, j, l) = chldms_oh(i, j, l) + xoh
          chldms_no3(i, j, l) = chldms_no3(i, j, l) + xn3
          chldms_x(i, j, l) = chldms_x(i, j, l) + xx
          chpso2(i, j, l) = chpso2(i, j, l) + pso2_dms(i, j, l)*airmas(i&
&            , j, l)/airmw*smw
          chpmsa(i, j, l) = chpmsa(i, j, l) + pmsa_dms(i, j, l)*airmas(i&
&            , j, l)/airmw*smw
        END DO
      END DO
    END DO
  END SUBROUTINE G_CHEM_DMS

!  Differentiation of chem_so2 in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: h2o2 pso4_so2 tc
!   with respect to varying inputs: h2o2 oh pso2_dms tmp airden
!                tc
  SUBROUTINE G_CHEM_SO2(imx, jmx, lmx, nmx, ndt1, tmp, g_tmp, airden, &
&    g_airden, airmas, cldf, oh, g_oh, h2o2, g_h2o2, tc, g_tc, tdry, &
&    cossza, chpso4, chlso2_oh, chlso2_aq, pso2_dms, g_pso2_dms, pso4_so2&
&    , g_pso4_so2)
    USE module_data_gocartchem
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nmx, ndt1, imx, jmx, lmx
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: tmp, airden, airmas
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: g_tmp, g_airden
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: cldf, oh
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: g_oh
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(INOUT) :: h2o2
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(INOUT) :: g_h2o2
    REAL*8, DIMENSION(imx, jmx), INTENT(IN) :: cossza
    REAL*8, INTENT(INOUT) :: tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: g_tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: tdry(imx, jmx, nmx)
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(INOUT) :: chpso4, chlso2_oh&
&    , chlso2_aq
    REAL*8, INTENT(IN) :: pso2_dms(imx, jmx, lmx)
    REAL*8, INTENT(IN) :: g_pso2_dms(imx, jmx, lmx)
    REAL*8, INTENT(OUT) :: pso4_so2(imx, jmx, lmx)
    REAL*8, INTENT(OUT) :: g_pso4_so2(imx, jmx, lmx)
    REAL*8 :: k0, kk, m, l1, l2, ld
    REAL*8 :: g_k0, g_kk, g_m, g_l1, g_l2
    REAL*8, PARAMETER :: f=1000./airmw*6.022d23*1.0d-6
    REAL*8, PARAMETER :: ki=1.5d-12
    INTEGER :: i, j, l
    REAL*8 :: so20, tk, f1, rk1, rk2, rk, rkt, so2_cd, fc, so2
    REAL*8 :: g_so20, g_tk, g_f1, g_rk1, g_rk, g_rkt, g_so2_cd, g_fc, &
&    g_so2
    REAL*8 :: pwx1
    REAL*8 :: g_pwx1
    REAL*8 :: pwr1
    REAL*8 :: g_pwr1
    g_pso4_so2 = 0.0_8
    DO l=1,lmx
      DO j=1,jmx
        DO i=1,imx
          g_so20 = g_tc(i, j, l, nso2)
          so20 = tc(i, j, l, nso2)
          g_tk = g_tmp(i, j, l)
          tk = tmp(i, j, l)
          g_k0 = -(3.0d-31*3.3*(300.0/tk)**2.3*300.0*g_tk/tk**2)
          k0 = 3.0d-31*(300.0/tk)**3.3
          g_m = f*g_airden(i, j, l)
          m = airden(i, j, l)*f
          g_kk = (g_k0*m+k0*g_m)/ki
          kk = k0*m/ki
          g_pwx1 = 2*LOG10(kk)*g_kk/(kk*LOG(10.0))
          pwx1 = 1.0 + LOG10(kk)**2
          IF (pwx1 .NE. 0.0_8) THEN
            g_f1 = -(g_pwx1/pwx1**2)
          ELSE
            g_f1 = 0.0_8
          END IF
          f1 = pwx1**(-1)
          g_pwr1 = 0.6**f1*LOG(0.6)*g_f1
          pwr1 = 0.6**f1
          g_rk1 = f*(((g_k0*m+k0*g_m)*(1.0+kk)-k0*m*g_kk)*pwr1*oh(i, j, &
&            l)*airden(i, j, l)/(1.0+kk)**2+k0*m*((g_pwr1*oh(i, j, l)+&
&            pwr1*g_oh(i, j, l))*airden(i, j, l)+pwr1*oh(i, j, l)*&
&            g_airden(i, j, l))/(1.0+kk))
          rk1 = k0*m/(1.0+kk)*pwr1*oh(i, j, l)*airden(i, j, l)*f
          rk2 = 0.0
          g_rk = g_rk1
          rk = rk1 + rk2
          g_rkt = REAL(ndt1)*g_rk
          rkt = rk*REAL(ndt1)
          IF (rk .GT. 0.0) THEN
            g_so2_cd = g_so20*EXP(-rkt) - so20*g_rkt*EXP(-rkt) + ((&
&              g_pso2_dms(i, j, l)*(1.0-EXP(-rkt))+pso2_dms(i, j, l)*&
&              g_rkt*EXP(-rkt))*rkt-pso2_dms(i, j, l)*(1.0-EXP(-rkt))*&
&              g_rkt)/rkt**2
            so2_cd = so20*EXP(-rkt) + pso2_dms(i, j, l)*(1.0-EXP(-rkt))/&
&              rkt
            g_l1 = (((g_so20-g_so2_cd+g_pso2_dms(i, j, l))*rk1+(so20-&
&              so2_cd+pso2_dms(i, j, l))*g_rk1)*rk-(so20-so2_cd+pso2_dms(&
&              i, j, l))*rk1*g_rk)/rk**2
            l1 = (so20-so2_cd+pso2_dms(i, j, l))*rk1/rk
            IF (l .EQ. 1) THEN
              ld = (so20-so2_cd+pso2_dms(i, j, l))*rk2/rk
            ELSE
              ld = 0.0
            END IF
          ELSE
            g_so2_cd = g_so20
            so2_cd = so20
            l1 = 0.0
            g_l1 = 0.0_8
          END IF
          fc = cldf(i, j, l)
          IF (fc .GT. 0.0 .AND. so2_cd .GT. 0.0 .AND. tk .GT. 258.0) &
&          THEN
            IF (so2_cd .GT. h2o2(i, j, l)) THEN
              g_fc = fc*(g_h2o2(i, j, l)*so2_cd-h2o2(i, j, l)*g_so2_cd)/&
&                so2_cd**2
              fc = fc*(h2o2(i, j, l)/so2_cd)
              g_h2o2(i, j, l) = (1.0-cldf(i, j, l))*g_h2o2(i, j, l)
              h2o2(i, j, l) = h2o2(i, j, l)*(1.0-cldf(i, j, l))
            ELSE
              g_h2o2(i, j, l) = g_h2o2(i, j, l)*(1.0-cldf(i, j, l)*&
&                so2_cd/h2o2(i, j, l)) - (cldf(i, j, l)*g_so2_cd*h2o2(i, &
&                j, l)-cldf(i, j, l)*so2_cd*g_h2o2(i, j, l))/h2o2(i, j, l&
&                )
              h2o2(i, j, l) = h2o2(i, j, l)*(1.0-cldf(i, j, l)*so2_cd/&
&                h2o2(i, j, l))
              g_fc = 0.0_8
            END IF
            g_so2 = g_so2_cd*(1.0-fc) - so2_cd*g_fc
            so2 = so2_cd*(1.0-fc)
            g_l2 = g_so2_cd*fc + so2_cd*g_fc
            l2 = so2_cd*fc
          ELSE
            g_so2 = g_so2_cd
            so2 = so2_cd
            l2 = 0.0
            g_l2 = 0.0_8
          END IF
          IF (so2 .LT. 1.0d-32) THEN
            so2 = 1.0d-32
            g_so2 = 0.0_8
          ELSE
            so2 = so2
          END IF
          g_tc(i, j, l, nso2) = g_so2
          tc(i, j, l, nso2) = so2
          IF (0.0d0 .LT. l1 + l2) THEN
            g_pso4_so2(i, j, l) = g_l1 + g_l2
            pso4_so2(i, j, l) = l1 + l2
          ELSE
            g_pso4_so2(i, j, l) = 0.0_8
            pso4_so2(i, j, l) = 0.0d0
          END IF
          chlso2_oh(i, j, l) = chlso2_oh(i, j, l) + l1*airmas(i, j, l)/&
&            airmw*smw
          chlso2_aq(i, j, l) = chlso2_aq(i, j, l) + l2*airmas(i, j, l)/&
&            airmw*smw
          IF (l .EQ. 1) chpso4(i, j, l) = chpso4(i, j, l) + pso4_so2(i, &
&              j, l)*airmas(i, j, l)/airmw*smw
        END DO
      END DO
    END DO
  END SUBROUTINE G_CHEM_SO2

!  Differentiation of chem_so4 in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: tc
!   with respect to varying inputs: pso4_so2 tc
  SUBROUTINE G_CHEM_SO4(imx, jmx, lmx, nmx, ndt1, airmas, tc, g_tc, tdry&
&    , cossza, pso4_so2, g_pso4_so2)
    USE module_data_gocartchem
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nmx, ndt1, imx, jmx, lmx
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: airmas
    REAL*8, INTENT(INOUT) :: tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: g_tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: tdry(imx, jmx, nmx)
    REAL*8, INTENT(IN) :: pso4_so2(imx, jmx, lmx)
    REAL*8, INTENT(IN) :: g_pso4_so2(imx, jmx, lmx)
    REAL*8, DIMENSION(imx, jmx), INTENT(IN) :: cossza
    INTEGER :: i, j, l
    REAL*8 :: so40, rk, rkt, so4
    REAL*8 :: g_so40, g_so4
    DO l=1,lmx
      DO j=1,jmx
        DO i=1,imx
          g_so40 = g_tc(i, j, l, nso4)
          so40 = tc(i, j, l, nso4)
          g_so4 = g_so40 + g_pso4_so2(i, j, l)
          so4 = so40 + pso4_so2(i, j, l)
          IF (pso4_so2(i, j, l) .LT. 0.) WRITE(0, *) &
&                                         'so4 routine, pso4 = ', &
&                                         pso4_so2(i, j, l), so4, so40
          IF (so4 .LT. 1.0d-32) THEN
            so4 = 1.0d-32
            g_so4 = 0.0_8
          ELSE
            so4 = so4
          END IF
          g_tc(i, j, l, nso4) = g_so4
          tc(i, j, l, nso4) = so4
        END DO
      END DO
    END DO
  END SUBROUTINE G_CHEM_SO4

!  Differentiation of chem_msa in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: tc
!   with respect to varying inputs: pmsa_dms tc
  SUBROUTINE G_CHEM_MSA(imx, jmx, lmx, nmx, ndt1, airmas, tc, g_tc, tdry&
&    , cossza, pmsa_dms, g_pmsa_dms)
    USE module_data_gocartchem
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nmx, ndt1, imx, jmx, lmx
    REAL*8, DIMENSION(imx, jmx, lmx), INTENT(IN) :: airmas
    REAL*8, DIMENSION(imx, jmx), INTENT(IN) :: cossza
    REAL*8, INTENT(INOUT) :: tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: g_tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: tdry(imx, jmx, nmx)
    REAL*8, INTENT(IN) :: pmsa_dms(imx, jmx, lmx)
    REAL*8, INTENT(IN) :: g_pmsa_dms(imx, jmx, lmx)
    REAL*8 :: msa0, msa, rk, rkt
    REAL*8 :: g_msa0, g_msa
    INTEGER :: i, j, l
    DO l=1,lmx
      DO j=1,jmx
        DO i=1,imx
          g_msa0 = g_tc(i, j, l, nmsa)
          msa0 = tc(i, j, l, nmsa)
          g_msa = g_msa0 + g_pmsa_dms(i, j, l)
          msa = msa0 + pmsa_dms(i, j, l)
          IF (msa .LT. 1.0d-32) THEN
            msa = 1.0d-32
            g_msa = 0.0_8
          ELSE
            msa = msa
          END IF
          g_tc(i, j, l, nmsa) = g_msa
          tc(i, j, l, nmsa) = msa
        END DO
      END DO
    END DO
  END SUBROUTINE G_CHEM_MSA

END MODULE g_module_gocart_chem
