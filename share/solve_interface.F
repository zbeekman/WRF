!WRF:MEDIATION_LAYER:ADT_BARRIER
!

SUBROUTINE solve_interface ( grid ) 

   USE module_domain
   USE module_timing
   USE module_driver_constants
   USE module_configure
   USE module_wrf_error
# ifdef WRF_CHEM
   USE mediation_pertmod_io , ONLY : find_nl_xtraj, read_xtraj
   USE esmf_timemod, ONLY : ESMF_TimeInc
#endif
   IMPLICIT NONE

   INTERFACE
#if (EM_CORE == 1 && DA_CORE != 1)
# include  <solve_em.int>
#endif
#if (NMM_CORE == 1)
# include  <solve_nmm.int>
#endif
#if (COAMPS_CORE == 1)
# include  <solve_coamps.int>
#endif
#if (EXP_CORE == 1)
# include  <solve_exp.int>
#endif
   END INTERFACE

   TYPE(domain) , INTENT(INOUT)  :: grid
# ifdef WRF_CHEM
!   TYPE(domain) :: grid_check
   CHARACTER*256          :: message
# endif
   TYPE (grid_config_rec_type)   :: config_flags

   INTEGER     :: idum1, idum2, ij

   CALL model_to_grid_config_rec ( grid%id , model_config_rec , config_flags )
   CALL set_scalar_indices_from_config ( grid%id , idum1 , idum2 )

#if (EM_CORE == 1 && DA_CORE != 1)
   
   IF      ( config_flags%dyn_opt == dyn_em_tl ) THEN
      CALL solve_em_tl  ( grid , config_flags  &
!
# include <actual_new_args.inc>
!
               )
# ifdef WRF_CHEM
   IF ( config_flags%chem_opt > 0  ) THEN
     CALL chem_driver_tl  ( grid , config_flags  &
!
# include <actual_new_args.inc>
!
               )
   ENDIF
# endif

   ELSE IF ( config_flags%dyn_opt == dyn_em_ad ) THEN
# ifdef WRF_CHEM
      IF ( config_flags%chem_opt > 0  ) THEN
         !Call solve_em to recalculate grid used by chem_driver
         grid%itimestep = grid%itimestep - 1
         CALL solve_em  ( grid , config_flags  &
!
# include <actual_new_args.inc>
!
               )

         CALL chem_driver_ad  ( grid , config_flags  &
!
# include <actual_new_args.inc>
!
               )
         grid%domain_clock%clockint%CurrTime =  ESMF_TimeInc (grid%domain_clock%clockint%CurrTime, &
                                grid%domain_clock%clockint%TimeStep )
         CALL domain_clock_get ( grid, current_timestr=message )
         CALL find_nl_xtraj (message) !Points xtraj_pointer to correct time
         CALL read_xtraj(message) !Reads same time as above, then advances xtraj_pointer
         CALL domain_clock_set( grid, time_step_seconds=config_flags%time_step )
         grid%domain_clock%clockint%CurrTime = ESMF_TimeInc (grid%domain_clock%clockint%CurrTime, &
                            grid%domain_clock%clockint%TimeStep )
         CALL domain_clock_set( grid, time_step_seconds=-1*config_flags%time_step )
      ENDIF
# endif

      CALL solve_em_ad  ( grid , config_flags  &
!
# include <actual_new_args.inc>
!
               )
   ELSE
      CALL solve_em  ( grid , config_flags  &
!
# include <actual_new_args.inc>
!
               )

# ifdef WRF_CHEM
   IF ( config_flags%chem_opt > 0  ) THEN

     CALL chem_driver  ( grid , config_flags  &
!
# include <actual_new_args.inc>
!
               )
   ENDIF
# endif

   END IF

#endif
#if (NMM_CORE == 1)
   CALL solve_nmm  ( grid , config_flags   &
!
# include <actual_new_args.inc>
!
               )
# ifdef WRF_CHEM
   IF ( config_flags%chem_opt > 0  ) THEN

     CALL chem_driver  ( grid , config_flags  &
!
# include <actual_new_args.inc>
!  
               )
   ENDIF
# endif
#endif
#if (COAMPS_CORE == 1)
   CALL solve_coamps  ( grid , config_flags   &
!
# include <actual_new_args.inc>
!
               )
#endif

! ###### 4. Edit share/solve_interface.F to add call to experimental core

#if (EXP_CORE == 1)
   CALL solve_exp  ( grid              &
!
# include <exp_actual_args.inc>
!
               )
#endif

END SUBROUTINE solve_interface

